"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/outlayer";
exports.ids = ["vendor-chunks/outlayer"];
exports.modules = {

/***/ "(ssr)/./node_modules/outlayer/item.js":
/*!***************************************!*\
  !*** ./node_modules/outlayer/item.js ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/**\n * Outlayer Item\n */ (function(window1, factory) {\n    // universal module definition\n    /* jshint strict: false */ /* globals define, module, require */ if (true) {\n        // AMD - RequireJS\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ev-emitter/ev-emitter */ \"(ssr)/./node_modules/ev-emitter/ev-emitter.js\"),\n            __webpack_require__(/*! get-size/get-size */ \"(ssr)/./node_modules/get-size/get-size.js\")\n        ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(window, function factory(EvEmitter, getSize) {\n    \"use strict\";\n    // ----- helpers ----- //\n    function isEmptyObj(obj) {\n        for(var prop in obj){\n            return false;\n        }\n        prop = null;\n        return true;\n    }\n    // -------------------------- CSS3 support -------------------------- //\n    var docElemStyle = document.documentElement.style;\n    var transitionProperty = typeof docElemStyle.transition == \"string\" ? \"transition\" : \"WebkitTransition\";\n    var transformProperty = typeof docElemStyle.transform == \"string\" ? \"transform\" : \"WebkitTransform\";\n    var transitionEndEvent = {\n        WebkitTransition: \"webkitTransitionEnd\",\n        transition: \"transitionend\"\n    }[transitionProperty];\n    // cache all vendor properties that could have vendor prefix\n    var vendorProperties = {\n        transform: transformProperty,\n        transition: transitionProperty,\n        transitionDuration: transitionProperty + \"Duration\",\n        transitionProperty: transitionProperty + \"Property\",\n        transitionDelay: transitionProperty + \"Delay\"\n    };\n    // -------------------------- Item -------------------------- //\n    function Item(element, layout) {\n        if (!element) {\n            return;\n        }\n        this.element = element;\n        // parent layout class, i.e. Masonry, Isotope, or Packery\n        this.layout = layout;\n        this.position = {\n            x: 0,\n            y: 0\n        };\n        this._create();\n    }\n    // inherit EvEmitter\n    var proto = Item.prototype = Object.create(EvEmitter.prototype);\n    proto.constructor = Item;\n    proto._create = function() {\n        // transition objects\n        this._transn = {\n            ingProperties: {},\n            clean: {},\n            onEnd: {}\n        };\n        this.css({\n            position: \"absolute\"\n        });\n    };\n    // trigger specified handler for event type\n    proto.handleEvent = function(event) {\n        var method = \"on\" + event.type;\n        if (this[method]) {\n            this[method](event);\n        }\n    };\n    proto.getSize = function() {\n        this.size = getSize(this.element);\n    };\n    /**\n * apply CSS styles to element\n * @param {Object} style\n */ proto.css = function(style) {\n        var elemStyle = this.element.style;\n        for(var prop in style){\n            // use vendor property if available\n            var supportedProp = vendorProperties[prop] || prop;\n            elemStyle[supportedProp] = style[prop];\n        }\n    };\n    // measure position, and sets it\n    proto.getPosition = function() {\n        var style = getComputedStyle(this.element);\n        var isOriginLeft = this.layout._getOption(\"originLeft\");\n        var isOriginTop = this.layout._getOption(\"originTop\");\n        var xValue = style[isOriginLeft ? \"left\" : \"right\"];\n        var yValue = style[isOriginTop ? \"top\" : \"bottom\"];\n        var x = parseFloat(xValue);\n        var y = parseFloat(yValue);\n        // convert percent to pixels\n        var layoutSize = this.layout.size;\n        if (xValue.indexOf(\"%\") != -1) {\n            x = x / 100 * layoutSize.width;\n        }\n        if (yValue.indexOf(\"%\") != -1) {\n            y = y / 100 * layoutSize.height;\n        }\n        // clean up 'auto' or other non-integer values\n        x = isNaN(x) ? 0 : x;\n        y = isNaN(y) ? 0 : y;\n        // remove padding from measurement\n        x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;\n        y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;\n        this.position.x = x;\n        this.position.y = y;\n    };\n    // set settled position, apply padding\n    proto.layoutPosition = function() {\n        var layoutSize = this.layout.size;\n        var style = {};\n        var isOriginLeft = this.layout._getOption(\"originLeft\");\n        var isOriginTop = this.layout._getOption(\"originTop\");\n        // x\n        var xPadding = isOriginLeft ? \"paddingLeft\" : \"paddingRight\";\n        var xProperty = isOriginLeft ? \"left\" : \"right\";\n        var xResetProperty = isOriginLeft ? \"right\" : \"left\";\n        var x = this.position.x + layoutSize[xPadding];\n        // set in percentage or pixels\n        style[xProperty] = this.getXValue(x);\n        // reset other property\n        style[xResetProperty] = \"\";\n        // y\n        var yPadding = isOriginTop ? \"paddingTop\" : \"paddingBottom\";\n        var yProperty = isOriginTop ? \"top\" : \"bottom\";\n        var yResetProperty = isOriginTop ? \"bottom\" : \"top\";\n        var y = this.position.y + layoutSize[yPadding];\n        // set in percentage or pixels\n        style[yProperty] = this.getYValue(y);\n        // reset other property\n        style[yResetProperty] = \"\";\n        this.css(style);\n        this.emitEvent(\"layout\", [\n            this\n        ]);\n    };\n    proto.getXValue = function(x) {\n        var isHorizontal = this.layout._getOption(\"horizontal\");\n        return this.layout.options.percentPosition && !isHorizontal ? x / this.layout.size.width * 100 + \"%\" : x + \"px\";\n    };\n    proto.getYValue = function(y) {\n        var isHorizontal = this.layout._getOption(\"horizontal\");\n        return this.layout.options.percentPosition && isHorizontal ? y / this.layout.size.height * 100 + \"%\" : y + \"px\";\n    };\n    proto._transitionTo = function(x, y) {\n        this.getPosition();\n        // get current x & y from top/left\n        var curX = this.position.x;\n        var curY = this.position.y;\n        var didNotMove = x == this.position.x && y == this.position.y;\n        // save end position\n        this.setPosition(x, y);\n        // if did not move and not transitioning, just go to layout\n        if (didNotMove && !this.isTransitioning) {\n            this.layoutPosition();\n            return;\n        }\n        var transX = x - curX;\n        var transY = y - curY;\n        var transitionStyle = {};\n        transitionStyle.transform = this.getTranslate(transX, transY);\n        this.transition({\n            to: transitionStyle,\n            onTransitionEnd: {\n                transform: this.layoutPosition\n            },\n            isCleaning: true\n        });\n    };\n    proto.getTranslate = function(x, y) {\n        // flip cooridinates if origin on right or bottom\n        var isOriginLeft = this.layout._getOption(\"originLeft\");\n        var isOriginTop = this.layout._getOption(\"originTop\");\n        x = isOriginLeft ? x : -x;\n        y = isOriginTop ? y : -y;\n        return \"translate3d(\" + x + \"px, \" + y + \"px, 0)\";\n    };\n    // non transition + transform support\n    proto.goTo = function(x, y) {\n        this.setPosition(x, y);\n        this.layoutPosition();\n    };\n    proto.moveTo = proto._transitionTo;\n    proto.setPosition = function(x, y) {\n        this.position.x = parseFloat(x);\n        this.position.y = parseFloat(y);\n    };\n    // ----- transition ----- //\n    /**\n * @param {Object} style - CSS\n * @param {Function} onTransitionEnd\n */ // non transition, just trigger callback\n    proto._nonTransition = function(args) {\n        this.css(args.to);\n        if (args.isCleaning) {\n            this._removeStyles(args.to);\n        }\n        for(var prop in args.onTransitionEnd){\n            args.onTransitionEnd[prop].call(this);\n        }\n    };\n    /**\n * proper transition\n * @param {Object} args - arguments\n *   @param {Object} to - style to transition to\n *   @param {Object} from - style to start transition from\n *   @param {Boolean} isCleaning - removes transition styles after transition\n *   @param {Function} onTransitionEnd - callback\n */ proto.transition = function(args) {\n        // redirect to nonTransition if no transition duration\n        if (!parseFloat(this.layout.options.transitionDuration)) {\n            this._nonTransition(args);\n            return;\n        }\n        var _transition = this._transn;\n        // keep track of onTransitionEnd callback by css property\n        for(var prop in args.onTransitionEnd){\n            _transition.onEnd[prop] = args.onTransitionEnd[prop];\n        }\n        // keep track of properties that are transitioning\n        for(prop in args.to){\n            _transition.ingProperties[prop] = true;\n            // keep track of properties to clean up when transition is done\n            if (args.isCleaning) {\n                _transition.clean[prop] = true;\n            }\n        }\n        // set from styles\n        if (args.from) {\n            this.css(args.from);\n            // force redraw. http://blog.alexmaccaw.com/css-transitions\n            var h = this.element.offsetHeight;\n            // hack for JSHint to hush about unused var\n            h = null;\n        }\n        // enable transition\n        this.enableTransition(args.to);\n        // set styles that are transitioning\n        this.css(args.to);\n        this.isTransitioning = true;\n    };\n    // dash before all cap letters, including first for\n    // WebkitTransform => -webkit-transform\n    function toDashedAll(str) {\n        return str.replace(/([A-Z])/g, function($1) {\n            return \"-\" + $1.toLowerCase();\n        });\n    }\n    var transitionProps = \"opacity,\" + toDashedAll(transformProperty);\n    proto.enableTransition = function() {\n        // HACK changing transitionProperty during a transition\n        // will cause transition to jump\n        if (this.isTransitioning) {\n            return;\n        }\n        // make `transition: foo, bar, baz` from style object\n        // HACK un-comment this when enableTransition can work\n        // while a transition is happening\n        // var transitionValues = [];\n        // for ( var prop in style ) {\n        //   // dash-ify camelCased properties like WebkitTransition\n        //   prop = vendorProperties[ prop ] || prop;\n        //   transitionValues.push( toDashedAll( prop ) );\n        // }\n        // munge number to millisecond, to match stagger\n        var duration = this.layout.options.transitionDuration;\n        duration = typeof duration == \"number\" ? duration + \"ms\" : duration;\n        // enable transition styles\n        this.css({\n            transitionProperty: transitionProps,\n            transitionDuration: duration,\n            transitionDelay: this.staggerDelay || 0\n        });\n        // listen for transition end event\n        this.element.addEventListener(transitionEndEvent, this, false);\n    };\n    // ----- events ----- //\n    proto.onwebkitTransitionEnd = function(event) {\n        this.ontransitionend(event);\n    };\n    proto.onotransitionend = function(event) {\n        this.ontransitionend(event);\n    };\n    // properties that I munge to make my life easier\n    var dashedVendorProperties = {\n        \"-webkit-transform\": \"transform\"\n    };\n    proto.ontransitionend = function(event) {\n        // disregard bubbled events from children\n        if (event.target !== this.element) {\n            return;\n        }\n        var _transition = this._transn;\n        // get property name of transitioned property, convert to prefix-free\n        var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;\n        // remove property that has completed transitioning\n        delete _transition.ingProperties[propertyName];\n        // check if any properties are still transitioning\n        if (isEmptyObj(_transition.ingProperties)) {\n            // all properties have completed transitioning\n            this.disableTransition();\n        }\n        // clean style\n        if (propertyName in _transition.clean) {\n            // clean up style\n            this.element.style[event.propertyName] = \"\";\n            delete _transition.clean[propertyName];\n        }\n        // trigger onTransitionEnd callback\n        if (propertyName in _transition.onEnd) {\n            var onTransitionEnd = _transition.onEnd[propertyName];\n            onTransitionEnd.call(this);\n            delete _transition.onEnd[propertyName];\n        }\n        this.emitEvent(\"transitionEnd\", [\n            this\n        ]);\n    };\n    proto.disableTransition = function() {\n        this.removeTransitionStyles();\n        this.element.removeEventListener(transitionEndEvent, this, false);\n        this.isTransitioning = false;\n    };\n    /**\n * removes style property from element\n * @param {Object} style\n**/ proto._removeStyles = function(style) {\n        // clean up transition styles\n        var cleanStyle = {};\n        for(var prop in style){\n            cleanStyle[prop] = \"\";\n        }\n        this.css(cleanStyle);\n    };\n    var cleanTransitionStyle = {\n        transitionProperty: \"\",\n        transitionDuration: \"\",\n        transitionDelay: \"\"\n    };\n    proto.removeTransitionStyles = function() {\n        // remove transition\n        this.css(cleanTransitionStyle);\n    };\n    // ----- stagger ----- //\n    proto.stagger = function(delay) {\n        delay = isNaN(delay) ? 0 : delay;\n        this.staggerDelay = delay + \"ms\";\n    };\n    // ----- show/hide/remove ----- //\n    // remove element from DOM\n    proto.removeElem = function() {\n        this.element.parentNode.removeChild(this.element);\n        // remove display: none\n        this.css({\n            display: \"\"\n        });\n        this.emitEvent(\"remove\", [\n            this\n        ]);\n    };\n    proto.remove = function() {\n        // just remove element if no transition support or no transition\n        if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {\n            this.removeElem();\n            return;\n        }\n        // start transition\n        this.once(\"transitionEnd\", function() {\n            this.removeElem();\n        });\n        this.hide();\n    };\n    proto.reveal = function() {\n        delete this.isHidden;\n        // remove display: none\n        this.css({\n            display: \"\"\n        });\n        var options = this.layout.options;\n        var onTransitionEnd = {};\n        var transitionEndProperty = this.getHideRevealTransitionEndProperty(\"visibleStyle\");\n        onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;\n        this.transition({\n            from: options.hiddenStyle,\n            to: options.visibleStyle,\n            isCleaning: true,\n            onTransitionEnd: onTransitionEnd\n        });\n    };\n    proto.onRevealTransitionEnd = function() {\n        // check if still visible\n        // during transition, item may have been hidden\n        if (!this.isHidden) {\n            this.emitEvent(\"reveal\");\n        }\n    };\n    /**\n * get style property use for hide/reveal transition end\n * @param {String} styleProperty - hiddenStyle/visibleStyle\n * @returns {String}\n */ proto.getHideRevealTransitionEndProperty = function(styleProperty) {\n        var optionStyle = this.layout.options[styleProperty];\n        // use opacity\n        if (optionStyle.opacity) {\n            return \"opacity\";\n        }\n        // get first property\n        for(var prop in optionStyle){\n            return prop;\n        }\n    };\n    proto.hide = function() {\n        // set flag\n        this.isHidden = true;\n        // remove display: none\n        this.css({\n            display: \"\"\n        });\n        var options = this.layout.options;\n        var onTransitionEnd = {};\n        var transitionEndProperty = this.getHideRevealTransitionEndProperty(\"hiddenStyle\");\n        onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;\n        this.transition({\n            from: options.visibleStyle,\n            to: options.hiddenStyle,\n            // keep hidden stuff hidden\n            isCleaning: true,\n            onTransitionEnd: onTransitionEnd\n        });\n    };\n    proto.onHideTransitionEnd = function() {\n        // check if still hidden\n        // during transition, item may have been un-hidden\n        if (this.isHidden) {\n            this.css({\n                display: \"none\"\n            });\n            this.emitEvent(\"hide\");\n        }\n    };\n    proto.destroy = function() {\n        this.css({\n            position: \"\",\n            left: \"\",\n            right: \"\",\n            top: \"\",\n            bottom: \"\",\n            transition: \"\",\n            transform: \"\"\n        });\n    };\n    return Item;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RTRDLHNCQUF1QixHQUFHLElBQUksQ0FBQ1EsbUJBQW1CO1FBRW5FLElBQUksQ0FBQzVILFVBQVUsQ0FBQztZQUNkaUYsTUFBTXRCLFFBQVE2RCxZQUFZO1lBQzFCakQsSUFBSVosUUFBUTRELFdBQVc7WUFDdkIsMkJBQTJCO1lBQzNCOUMsWUFBWTtZQUNaRCxpQkFBaUJBO1FBQ25CO0lBQ0Y7SUFFQTFELE1BQU04RyxtQkFBbUIsR0FBRztRQUMxQix3QkFBd0I7UUFDeEIsa0RBQWtEO1FBQ2xELElBQUssSUFBSSxDQUFDVCxRQUFRLEVBQUc7WUFDbkIsSUFBSSxDQUFDNUYsR0FBRyxDQUFDO2dCQUFFdUYsU0FBUztZQUFPO1lBQzNCLElBQUksQ0FBQ3JELFNBQVMsQ0FBQztRQUNqQjtJQUNGO0lBRUEzQyxNQUFNK0csT0FBTyxHQUFHO1FBQ2QsSUFBSSxDQUFDdEcsR0FBRyxDQUFDO1lBQ1BiLFVBQVU7WUFDVm9ILE1BQU07WUFDTkMsT0FBTztZQUNQQyxLQUFLO1lBQ0xDLFFBQVE7WUFDUmpJLFlBQVk7WUFDWkUsV0FBVztRQUNiO0lBQ0Y7SUFFQSxPQUFPYjtBQUVQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJldG8tcmVhY3QvLi9ub2RlX21vZHVsZXMvb3V0bGF5ZXIvaXRlbS5qcz85YTU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT3V0bGF5ZXIgSXRlbVxuICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qIGdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTUQgLSBSZXF1aXJlSlNcbiAgICBkZWZpbmUoIFtcbiAgICAgICAgJ2V2LWVtaXR0ZXIvZXYtZW1pdHRlcicsXG4gICAgICAgICdnZXQtc2l6ZS9nZXQtc2l6ZSdcbiAgICAgIF0sXG4gICAgICBmYWN0b3J5XG4gICAgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KUyAtIEJyb3dzZXJpZnksIFdlYnBhY2tcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICByZXF1aXJlKCdldi1lbWl0dGVyJyksXG4gICAgICByZXF1aXJlKCdnZXQtc2l6ZScpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5PdXRsYXllciA9IHt9O1xuICAgIHdpbmRvdy5PdXRsYXllci5JdGVtID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdy5FdkVtaXR0ZXIsXG4gICAgICB3aW5kb3cuZ2V0U2l6ZVxuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCBFdkVtaXR0ZXIsIGdldFNpemUgKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tIGhlbHBlcnMgLS0tLS0gLy9cblxuZnVuY3Rpb24gaXNFbXB0eU9iaiggb2JqICkge1xuICBmb3IgKCB2YXIgcHJvcCBpbiBvYmogKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHByb3AgPSBudWxsO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ1NTMyBzdXBwb3J0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cblxudmFyIGRvY0VsZW1TdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcblxudmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9IHR5cGVvZiBkb2NFbGVtU3R5bGUudHJhbnNpdGlvbiA9PSAnc3RyaW5nJyA/XG4gICd0cmFuc2l0aW9uJyA6ICdXZWJraXRUcmFuc2l0aW9uJztcbnZhciB0cmFuc2Zvcm1Qcm9wZXJ0eSA9IHR5cGVvZiBkb2NFbGVtU3R5bGUudHJhbnNmb3JtID09ICdzdHJpbmcnID9cbiAgJ3RyYW5zZm9ybScgOiAnV2Via2l0VHJhbnNmb3JtJztcblxudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9IHtcbiAgV2Via2l0VHJhbnNpdGlvbjogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICB0cmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCdcbn1bIHRyYW5zaXRpb25Qcm9wZXJ0eSBdO1xuXG4vLyBjYWNoZSBhbGwgdmVuZG9yIHByb3BlcnRpZXMgdGhhdCBjb3VsZCBoYXZlIHZlbmRvciBwcmVmaXhcbnZhciB2ZW5kb3JQcm9wZXJ0aWVzID0ge1xuICB0cmFuc2Zvcm06IHRyYW5zZm9ybVByb3BlcnR5LFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uUHJvcGVydHksXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvblByb3BlcnR5ICsgJ0R1cmF0aW9uJyxcbiAgdHJhbnNpdGlvblByb3BlcnR5OiB0cmFuc2l0aW9uUHJvcGVydHkgKyAnUHJvcGVydHknLFxuICB0cmFuc2l0aW9uRGVsYXk6IHRyYW5zaXRpb25Qcm9wZXJ0eSArICdEZWxheSdcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEl0ZW0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gSXRlbSggZWxlbWVudCwgbGF5b3V0ICkge1xuICBpZiAoICFlbGVtZW50ICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIC8vIHBhcmVudCBsYXlvdXQgY2xhc3MsIGkuZS4gTWFzb25yeSwgSXNvdG9wZSwgb3IgUGFja2VyeVxuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5wb3NpdGlvbiA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICB0aGlzLl9jcmVhdGUoKTtcbn1cblxuLy8gaW5oZXJpdCBFdkVtaXR0ZXJcbnZhciBwcm90byA9IEl0ZW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZFbWl0dGVyLnByb3RvdHlwZSApO1xucHJvdG8uY29uc3RydWN0b3IgPSBJdGVtO1xuXG5wcm90by5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIHRyYW5zaXRpb24gb2JqZWN0c1xuICB0aGlzLl90cmFuc24gPSB7XG4gICAgaW5nUHJvcGVydGllczoge30sXG4gICAgY2xlYW46IHt9LFxuICAgIG9uRW5kOiB7fVxuICB9O1xuXG4gIHRoaXMuY3NzKHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICB9KTtcbn07XG5cbi8vIHRyaWdnZXIgc3BlY2lmaWVkIGhhbmRsZXIgZm9yIGV2ZW50IHR5cGVcbnByb3RvLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB2YXIgbWV0aG9kID0gJ29uJyArIGV2ZW50LnR5cGU7XG4gIGlmICggdGhpc1sgbWV0aG9kIF0gKSB7XG4gICAgdGhpc1sgbWV0aG9kIF0oIGV2ZW50ICk7XG4gIH1cbn07XG5cbnByb3RvLmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zaXplID0gZ2V0U2l6ZSggdGhpcy5lbGVtZW50ICk7XG59O1xuXG4vKipcbiAqIGFwcGx5IENTUyBzdHlsZXMgdG8gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gKi9cbnByb3RvLmNzcyA9IGZ1bmN0aW9uKCBzdHlsZSApIHtcbiAgdmFyIGVsZW1TdHlsZSA9IHRoaXMuZWxlbWVudC5zdHlsZTtcblxuICBmb3IgKCB2YXIgcHJvcCBpbiBzdHlsZSApIHtcbiAgICAvLyB1c2UgdmVuZG9yIHByb3BlcnR5IGlmIGF2YWlsYWJsZVxuICAgIHZhciBzdXBwb3J0ZWRQcm9wID0gdmVuZG9yUHJvcGVydGllc1sgcHJvcCBdIHx8IHByb3A7XG4gICAgZWxlbVN0eWxlWyBzdXBwb3J0ZWRQcm9wIF0gPSBzdHlsZVsgcHJvcCBdO1xuICB9XG59O1xuXG4gLy8gbWVhc3VyZSBwb3NpdGlvbiwgYW5kIHNldHMgaXRcbnByb3RvLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoIHRoaXMuZWxlbWVudCApO1xuICB2YXIgaXNPcmlnaW5MZWZ0ID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luTGVmdCcpO1xuICB2YXIgaXNPcmlnaW5Ub3AgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5Ub3AnKTtcbiAgdmFyIHhWYWx1ZSA9IHN0eWxlWyBpc09yaWdpbkxlZnQgPyAnbGVmdCcgOiAncmlnaHQnIF07XG4gIHZhciB5VmFsdWUgPSBzdHlsZVsgaXNPcmlnaW5Ub3AgPyAndG9wJyA6ICdib3R0b20nIF07XG4gIHZhciB4ID0gcGFyc2VGbG9hdCggeFZhbHVlICk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdCggeVZhbHVlICk7XG4gIC8vIGNvbnZlcnQgcGVyY2VudCB0byBwaXhlbHNcbiAgdmFyIGxheW91dFNpemUgPSB0aGlzLmxheW91dC5zaXplO1xuICBpZiAoIHhWYWx1ZS5pbmRleE9mKCclJykgIT0gLTEgKSB7XG4gICAgeCA9ICggeCAvIDEwMCApICogbGF5b3V0U2l6ZS53aWR0aDtcbiAgfVxuICBpZiAoIHlWYWx1ZS5pbmRleE9mKCclJykgIT0gLTEgKSB7XG4gICAgeSA9ICggeSAvIDEwMCApICogbGF5b3V0U2l6ZS5oZWlnaHQ7XG4gIH1cbiAgLy8gY2xlYW4gdXAgJ2F1dG8nIG9yIG90aGVyIG5vbi1pbnRlZ2VyIHZhbHVlc1xuICB4ID0gaXNOYU4oIHggKSA/IDAgOiB4O1xuICB5ID0gaXNOYU4oIHkgKSA/IDAgOiB5O1xuICAvLyByZW1vdmUgcGFkZGluZyBmcm9tIG1lYXN1cmVtZW50XG4gIHggLT0gaXNPcmlnaW5MZWZ0ID8gbGF5b3V0U2l6ZS5wYWRkaW5nTGVmdCA6IGxheW91dFNpemUucGFkZGluZ1JpZ2h0O1xuICB5IC09IGlzT3JpZ2luVG9wID8gbGF5b3V0U2l6ZS5wYWRkaW5nVG9wIDogbGF5b3V0U2l6ZS5wYWRkaW5nQm90dG9tO1xuXG4gIHRoaXMucG9zaXRpb24ueCA9IHg7XG4gIHRoaXMucG9zaXRpb24ueSA9IHk7XG59O1xuXG4vLyBzZXQgc2V0dGxlZCBwb3NpdGlvbiwgYXBwbHkgcGFkZGluZ1xucHJvdG8ubGF5b3V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxheW91dFNpemUgPSB0aGlzLmxheW91dC5zaXplO1xuICB2YXIgc3R5bGUgPSB7fTtcbiAgdmFyIGlzT3JpZ2luTGVmdCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpbkxlZnQnKTtcbiAgdmFyIGlzT3JpZ2luVG9wID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luVG9wJyk7XG5cbiAgLy8geFxuICB2YXIgeFBhZGRpbmcgPSBpc09yaWdpbkxlZnQgPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XG4gIHZhciB4UHJvcGVydHkgPSBpc09yaWdpbkxlZnQgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB2YXIgeFJlc2V0UHJvcGVydHkgPSBpc09yaWdpbkxlZnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuXG4gIHZhciB4ID0gdGhpcy5wb3NpdGlvbi54ICsgbGF5b3V0U2l6ZVsgeFBhZGRpbmcgXTtcbiAgLy8gc2V0IGluIHBlcmNlbnRhZ2Ugb3IgcGl4ZWxzXG4gIHN0eWxlWyB4UHJvcGVydHkgXSA9IHRoaXMuZ2V0WFZhbHVlKCB4ICk7XG4gIC8vIHJlc2V0IG90aGVyIHByb3BlcnR5XG4gIHN0eWxlWyB4UmVzZXRQcm9wZXJ0eSBdID0gJyc7XG5cbiAgLy8geVxuICB2YXIgeVBhZGRpbmcgPSBpc09yaWdpblRvcCA/ICdwYWRkaW5nVG9wJyA6ICdwYWRkaW5nQm90dG9tJztcbiAgdmFyIHlQcm9wZXJ0eSA9IGlzT3JpZ2luVG9wID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgdmFyIHlSZXNldFByb3BlcnR5ID0gaXNPcmlnaW5Ub3AgPyAnYm90dG9tJyA6ICd0b3AnO1xuXG4gIHZhciB5ID0gdGhpcy5wb3NpdGlvbi55ICsgbGF5b3V0U2l6ZVsgeVBhZGRpbmcgXTtcbiAgLy8gc2V0IGluIHBlcmNlbnRhZ2Ugb3IgcGl4ZWxzXG4gIHN0eWxlWyB5UHJvcGVydHkgXSA9IHRoaXMuZ2V0WVZhbHVlKCB5ICk7XG4gIC8vIHJlc2V0IG90aGVyIHByb3BlcnR5XG4gIHN0eWxlWyB5UmVzZXRQcm9wZXJ0eSBdID0gJyc7XG5cbiAgdGhpcy5jc3MoIHN0eWxlICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAnbGF5b3V0JywgWyB0aGlzIF0gKTtcbn07XG5cbnByb3RvLmdldFhWYWx1ZSA9IGZ1bmN0aW9uKCB4ICkge1xuICB2YXIgaXNIb3Jpem9udGFsID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignaG9yaXpvbnRhbCcpO1xuICByZXR1cm4gdGhpcy5sYXlvdXQub3B0aW9ucy5wZXJjZW50UG9zaXRpb24gJiYgIWlzSG9yaXpvbnRhbCA/XG4gICAgKCAoIHggLyB0aGlzLmxheW91dC5zaXplLndpZHRoICkgKiAxMDAgKSArICclJyA6IHggKyAncHgnO1xufTtcblxucHJvdG8uZ2V0WVZhbHVlID0gZnVuY3Rpb24oIHkgKSB7XG4gIHZhciBpc0hvcml6b250YWwgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdob3Jpem9udGFsJyk7XG4gIHJldHVybiB0aGlzLmxheW91dC5vcHRpb25zLnBlcmNlbnRQb3NpdGlvbiAmJiBpc0hvcml6b250YWwgP1xuICAgICggKCB5IC8gdGhpcy5sYXlvdXQuc2l6ZS5oZWlnaHQgKSAqIDEwMCApICsgJyUnIDogeSArICdweCc7XG59O1xuXG5wcm90by5fdHJhbnNpdGlvblRvID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gIHRoaXMuZ2V0UG9zaXRpb24oKTtcbiAgLy8gZ2V0IGN1cnJlbnQgeCAmIHkgZnJvbSB0b3AvbGVmdFxuICB2YXIgY3VyWCA9IHRoaXMucG9zaXRpb24ueDtcbiAgdmFyIGN1clkgPSB0aGlzLnBvc2l0aW9uLnk7XG5cbiAgdmFyIGRpZE5vdE1vdmUgPSB4ID09IHRoaXMucG9zaXRpb24ueCAmJiB5ID09IHRoaXMucG9zaXRpb24ueTtcblxuICAvLyBzYXZlIGVuZCBwb3NpdGlvblxuICB0aGlzLnNldFBvc2l0aW9uKCB4LCB5ICk7XG5cbiAgLy8gaWYgZGlkIG5vdCBtb3ZlIGFuZCBub3QgdHJhbnNpdGlvbmluZywganVzdCBnbyB0byBsYXlvdXRcbiAgaWYgKCBkaWROb3RNb3ZlICYmICF0aGlzLmlzVHJhbnNpdGlvbmluZyApIHtcbiAgICB0aGlzLmxheW91dFBvc2l0aW9uKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRyYW5zWCA9IHggLSBjdXJYO1xuICB2YXIgdHJhbnNZID0geSAtIGN1clk7XG4gIHZhciB0cmFuc2l0aW9uU3R5bGUgPSB7fTtcbiAgdHJhbnNpdGlvblN0eWxlLnRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNsYXRlKCB0cmFuc1gsIHRyYW5zWSApO1xuXG4gIHRoaXMudHJhbnNpdGlvbih7XG4gICAgdG86IHRyYW5zaXRpb25TdHlsZSxcbiAgICBvblRyYW5zaXRpb25FbmQ6IHtcbiAgICAgIHRyYW5zZm9ybTogdGhpcy5sYXlvdXRQb3NpdGlvblxuICAgIH0sXG4gICAgaXNDbGVhbmluZzogdHJ1ZVxuICB9KTtcbn07XG5cbnByb3RvLmdldFRyYW5zbGF0ZSA9IGZ1bmN0aW9uKCB4LCB5ICkge1xuICAvLyBmbGlwIGNvb3JpZGluYXRlcyBpZiBvcmlnaW4gb24gcmlnaHQgb3IgYm90dG9tXG4gIHZhciBpc09yaWdpbkxlZnQgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5MZWZ0Jyk7XG4gIHZhciBpc09yaWdpblRvcCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpblRvcCcpO1xuICB4ID0gaXNPcmlnaW5MZWZ0ID8geCA6IC14O1xuICB5ID0gaXNPcmlnaW5Ub3AgPyB5IDogLXk7XG4gIHJldHVybiAndHJhbnNsYXRlM2QoJyArIHggKyAncHgsICcgKyB5ICsgJ3B4LCAwKSc7XG59O1xuXG4vLyBub24gdHJhbnNpdGlvbiArIHRyYW5zZm9ybSBzdXBwb3J0XG5wcm90by5nb1RvID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gIHRoaXMuc2V0UG9zaXRpb24oIHgsIHkgKTtcbiAgdGhpcy5sYXlvdXRQb3NpdGlvbigpO1xufTtcblxucHJvdG8ubW92ZVRvID0gcHJvdG8uX3RyYW5zaXRpb25UbztcblxucHJvdG8uc2V0UG9zaXRpb24gPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgdGhpcy5wb3NpdGlvbi54ID0gcGFyc2VGbG9hdCggeCApO1xuICB0aGlzLnBvc2l0aW9uLnkgPSBwYXJzZUZsb2F0KCB5ICk7XG59O1xuXG4vLyAtLS0tLSB0cmFuc2l0aW9uIC0tLS0tIC8vXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIC0gQ1NTXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblRyYW5zaXRpb25FbmRcbiAqL1xuXG4vLyBub24gdHJhbnNpdGlvbiwganVzdCB0cmlnZ2VyIGNhbGxiYWNrXG5wcm90by5fbm9uVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCBhcmdzICkge1xuICB0aGlzLmNzcyggYXJncy50byApO1xuICBpZiAoIGFyZ3MuaXNDbGVhbmluZyApIHtcbiAgICB0aGlzLl9yZW1vdmVTdHlsZXMoIGFyZ3MudG8gKTtcbiAgfVxuICBmb3IgKCB2YXIgcHJvcCBpbiBhcmdzLm9uVHJhbnNpdGlvbkVuZCApIHtcbiAgICBhcmdzLm9uVHJhbnNpdGlvbkVuZFsgcHJvcCBdLmNhbGwoIHRoaXMgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBwcm9wZXIgdHJhbnNpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBhcmd1bWVudHNcbiAqICAgQHBhcmFtIHtPYmplY3R9IHRvIC0gc3R5bGUgdG8gdHJhbnNpdGlvbiB0b1xuICogICBAcGFyYW0ge09iamVjdH0gZnJvbSAtIHN0eWxlIHRvIHN0YXJ0IHRyYW5zaXRpb24gZnJvbVxuICogICBAcGFyYW0ge0Jvb2xlYW59IGlzQ2xlYW5pbmcgLSByZW1vdmVzIHRyYW5zaXRpb24gc3R5bGVzIGFmdGVyIHRyYW5zaXRpb25cbiAqICAgQHBhcmFtIHtGdW5jdGlvbn0gb25UcmFuc2l0aW9uRW5kIC0gY2FsbGJhY2tcbiAqL1xucHJvdG8udHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCBhcmdzICkge1xuICAvLyByZWRpcmVjdCB0byBub25UcmFuc2l0aW9uIGlmIG5vIHRyYW5zaXRpb24gZHVyYXRpb25cbiAgaWYgKCAhcGFyc2VGbG9hdCggdGhpcy5sYXlvdXQub3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb24gKSApIHtcbiAgICB0aGlzLl9ub25UcmFuc2l0aW9uKCBhcmdzICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF90cmFuc2l0aW9uID0gdGhpcy5fdHJhbnNuO1xuICAvLyBrZWVwIHRyYWNrIG9mIG9uVHJhbnNpdGlvbkVuZCBjYWxsYmFjayBieSBjc3MgcHJvcGVydHlcbiAgZm9yICggdmFyIHByb3AgaW4gYXJncy5vblRyYW5zaXRpb25FbmQgKSB7XG4gICAgX3RyYW5zaXRpb24ub25FbmRbIHByb3AgXSA9IGFyZ3Mub25UcmFuc2l0aW9uRW5kWyBwcm9wIF07XG4gIH1cbiAgLy8ga2VlcCB0cmFjayBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIHRyYW5zaXRpb25pbmdcbiAgZm9yICggcHJvcCBpbiBhcmdzLnRvICkge1xuICAgIF90cmFuc2l0aW9uLmluZ1Byb3BlcnRpZXNbIHByb3AgXSA9IHRydWU7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBwcm9wZXJ0aWVzIHRvIGNsZWFuIHVwIHdoZW4gdHJhbnNpdGlvbiBpcyBkb25lXG4gICAgaWYgKCBhcmdzLmlzQ2xlYW5pbmcgKSB7XG4gICAgICBfdHJhbnNpdGlvbi5jbGVhblsgcHJvcCBdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgZnJvbSBzdHlsZXNcbiAgaWYgKCBhcmdzLmZyb20gKSB7XG4gICAgdGhpcy5jc3MoIGFyZ3MuZnJvbSApO1xuICAgIC8vIGZvcmNlIHJlZHJhdy4gaHR0cDovL2Jsb2cuYWxleG1hY2Nhdy5jb20vY3NzLXRyYW5zaXRpb25zXG4gICAgdmFyIGggPSB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIC8vIGhhY2sgZm9yIEpTSGludCB0byBodXNoIGFib3V0IHVudXNlZCB2YXJcbiAgICBoID0gbnVsbDtcbiAgfVxuICAvLyBlbmFibGUgdHJhbnNpdGlvblxuICB0aGlzLmVuYWJsZVRyYW5zaXRpb24oIGFyZ3MudG8gKTtcbiAgLy8gc2V0IHN0eWxlcyB0aGF0IGFyZSB0cmFuc2l0aW9uaW5nXG4gIHRoaXMuY3NzKCBhcmdzLnRvICk7XG5cbiAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuXG59O1xuXG4vLyBkYXNoIGJlZm9yZSBhbGwgY2FwIGxldHRlcnMsIGluY2x1ZGluZyBmaXJzdCBmb3Jcbi8vIFdlYmtpdFRyYW5zZm9ybSA9PiAtd2Via2l0LXRyYW5zZm9ybVxuZnVuY3Rpb24gdG9EYXNoZWRBbGwoIHN0ciApIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKCAvKFtBLVpdKS9nLCBmdW5jdGlvbiggJDEgKSB7XG4gICAgcmV0dXJuICctJyArICQxLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0gJ29wYWNpdHksJyArIHRvRGFzaGVkQWxsKCB0cmFuc2Zvcm1Qcm9wZXJ0eSApO1xuXG5wcm90by5lbmFibGVUcmFuc2l0aW9uID0gZnVuY3Rpb24oLyogc3R5bGUgKi8pIHtcbiAgLy8gSEFDSyBjaGFuZ2luZyB0cmFuc2l0aW9uUHJvcGVydHkgZHVyaW5nIGEgdHJhbnNpdGlvblxuICAvLyB3aWxsIGNhdXNlIHRyYW5zaXRpb24gdG8ganVtcFxuICBpZiAoIHRoaXMuaXNUcmFuc2l0aW9uaW5nICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIG1ha2UgYHRyYW5zaXRpb246IGZvbywgYmFyLCBiYXpgIGZyb20gc3R5bGUgb2JqZWN0XG4gIC8vIEhBQ0sgdW4tY29tbWVudCB0aGlzIHdoZW4gZW5hYmxlVHJhbnNpdGlvbiBjYW4gd29ya1xuICAvLyB3aGlsZSBhIHRyYW5zaXRpb24gaXMgaGFwcGVuaW5nXG4gIC8vIHZhciB0cmFuc2l0aW9uVmFsdWVzID0gW107XG4gIC8vIGZvciAoIHZhciBwcm9wIGluIHN0eWxlICkge1xuICAvLyAgIC8vIGRhc2gtaWZ5IGNhbWVsQ2FzZWQgcHJvcGVydGllcyBsaWtlIFdlYmtpdFRyYW5zaXRpb25cbiAgLy8gICBwcm9wID0gdmVuZG9yUHJvcGVydGllc1sgcHJvcCBdIHx8IHByb3A7XG4gIC8vICAgdHJhbnNpdGlvblZhbHVlcy5wdXNoKCB0b0Rhc2hlZEFsbCggcHJvcCApICk7XG4gIC8vIH1cbiAgLy8gbXVuZ2UgbnVtYmVyIHRvIG1pbGxpc2Vjb25kLCB0byBtYXRjaCBzdGFnZ2VyXG4gIHZhciBkdXJhdGlvbiA9IHRoaXMubGF5b3V0Lm9wdGlvbnMudHJhbnNpdGlvbkR1cmF0aW9uO1xuICBkdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PSAnbnVtYmVyJyA/IGR1cmF0aW9uICsgJ21zJyA6IGR1cmF0aW9uO1xuICAvLyBlbmFibGUgdHJhbnNpdGlvbiBzdHlsZXNcbiAgdGhpcy5jc3Moe1xuICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogdHJhbnNpdGlvblByb3BzLFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbjogZHVyYXRpb24sXG4gICAgdHJhbnNpdGlvbkRlbGF5OiB0aGlzLnN0YWdnZXJEZWxheSB8fCAwXG4gIH0pO1xuICAvLyBsaXN0ZW4gZm9yIHRyYW5zaXRpb24gZW5kIGV2ZW50XG4gIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0cmFuc2l0aW9uRW5kRXZlbnQsIHRoaXMsIGZhbHNlICk7XG59O1xuXG4vLyAtLS0tLSBldmVudHMgLS0tLS0gLy9cblxucHJvdG8ub253ZWJraXRUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLm9udHJhbnNpdGlvbmVuZCggZXZlbnQgKTtcbn07XG5cbnByb3RvLm9ub3RyYW5zaXRpb25lbmQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHRoaXMub250cmFuc2l0aW9uZW5kKCBldmVudCApO1xufTtcblxuLy8gcHJvcGVydGllcyB0aGF0IEkgbXVuZ2UgdG8gbWFrZSBteSBsaWZlIGVhc2llclxudmFyIGRhc2hlZFZlbmRvclByb3BlcnRpZXMgPSB7XG4gICctd2Via2l0LXRyYW5zZm9ybSc6ICd0cmFuc2Zvcm0nXG59O1xuXG5wcm90by5vbnRyYW5zaXRpb25lbmQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIC8vIGRpc3JlZ2FyZCBidWJibGVkIGV2ZW50cyBmcm9tIGNoaWxkcmVuXG4gIGlmICggZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmVsZW1lbnQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBfdHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zbjtcbiAgLy8gZ2V0IHByb3BlcnR5IG5hbWUgb2YgdHJhbnNpdGlvbmVkIHByb3BlcnR5LCBjb252ZXJ0IHRvIHByZWZpeC1mcmVlXG4gIHZhciBwcm9wZXJ0eU5hbWUgPSBkYXNoZWRWZW5kb3JQcm9wZXJ0aWVzWyBldmVudC5wcm9wZXJ0eU5hbWUgXSB8fCBldmVudC5wcm9wZXJ0eU5hbWU7XG5cbiAgLy8gcmVtb3ZlIHByb3BlcnR5IHRoYXQgaGFzIGNvbXBsZXRlZCB0cmFuc2l0aW9uaW5nXG4gIGRlbGV0ZSBfdHJhbnNpdGlvbi5pbmdQcm9wZXJ0aWVzWyBwcm9wZXJ0eU5hbWUgXTtcbiAgLy8gY2hlY2sgaWYgYW55IHByb3BlcnRpZXMgYXJlIHN0aWxsIHRyYW5zaXRpb25pbmdcbiAgaWYgKCBpc0VtcHR5T2JqKCBfdHJhbnNpdGlvbi5pbmdQcm9wZXJ0aWVzICkgKSB7XG4gICAgLy8gYWxsIHByb3BlcnRpZXMgaGF2ZSBjb21wbGV0ZWQgdHJhbnNpdGlvbmluZ1xuICAgIHRoaXMuZGlzYWJsZVRyYW5zaXRpb24oKTtcbiAgfVxuICAvLyBjbGVhbiBzdHlsZVxuICBpZiAoIHByb3BlcnR5TmFtZSBpbiBfdHJhbnNpdGlvbi5jbGVhbiApIHtcbiAgICAvLyBjbGVhbiB1cCBzdHlsZVxuICAgIHRoaXMuZWxlbWVudC5zdHlsZVsgZXZlbnQucHJvcGVydHlOYW1lIF0gPSAnJztcbiAgICBkZWxldGUgX3RyYW5zaXRpb24uY2xlYW5bIHByb3BlcnR5TmFtZSBdO1xuICB9XG4gIC8vIHRyaWdnZXIgb25UcmFuc2l0aW9uRW5kIGNhbGxiYWNrXG4gIGlmICggcHJvcGVydHlOYW1lIGluIF90cmFuc2l0aW9uLm9uRW5kICkge1xuICAgIHZhciBvblRyYW5zaXRpb25FbmQgPSBfdHJhbnNpdGlvbi5vbkVuZFsgcHJvcGVydHlOYW1lIF07XG4gICAgb25UcmFuc2l0aW9uRW5kLmNhbGwoIHRoaXMgKTtcbiAgICBkZWxldGUgX3RyYW5zaXRpb24ub25FbmRbIHByb3BlcnR5TmFtZSBdO1xuICB9XG5cbiAgdGhpcy5lbWl0RXZlbnQoICd0cmFuc2l0aW9uRW5kJywgWyB0aGlzIF0gKTtcbn07XG5cbnByb3RvLmRpc2FibGVUcmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVtb3ZlVHJhbnNpdGlvblN0eWxlcygpO1xuICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHJhbnNpdGlvbkVuZEV2ZW50LCB0aGlzLCBmYWxzZSApO1xuICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiByZW1vdmVzIHN0eWxlIHByb3BlcnR5IGZyb20gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4qKi9cbnByb3RvLl9yZW1vdmVTdHlsZXMgPSBmdW5jdGlvbiggc3R5bGUgKSB7XG4gIC8vIGNsZWFuIHVwIHRyYW5zaXRpb24gc3R5bGVzXG4gIHZhciBjbGVhblN0eWxlID0ge307XG4gIGZvciAoIHZhciBwcm9wIGluIHN0eWxlICkge1xuICAgIGNsZWFuU3R5bGVbIHByb3AgXSA9ICcnO1xuICB9XG4gIHRoaXMuY3NzKCBjbGVhblN0eWxlICk7XG59O1xuXG52YXIgY2xlYW5UcmFuc2l0aW9uU3R5bGUgPSB7XG4gIHRyYW5zaXRpb25Qcm9wZXJ0eTogJycsXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogJycsXG4gIHRyYW5zaXRpb25EZWxheTogJydcbn07XG5cbnByb3RvLnJlbW92ZVRyYW5zaXRpb25TdHlsZXMgPSBmdW5jdGlvbigpIHtcbiAgLy8gcmVtb3ZlIHRyYW5zaXRpb25cbiAgdGhpcy5jc3MoIGNsZWFuVHJhbnNpdGlvblN0eWxlICk7XG59O1xuXG4vLyAtLS0tLSBzdGFnZ2VyIC0tLS0tIC8vXG5cbnByb3RvLnN0YWdnZXIgPSBmdW5jdGlvbiggZGVsYXkgKSB7XG4gIGRlbGF5ID0gaXNOYU4oIGRlbGF5ICkgPyAwIDogZGVsYXk7XG4gIHRoaXMuc3RhZ2dlckRlbGF5ID0gZGVsYXkgKyAnbXMnO1xufTtcblxuLy8gLS0tLS0gc2hvdy9oaWRlL3JlbW92ZSAtLS0tLSAvL1xuXG4vLyByZW1vdmUgZWxlbWVudCBmcm9tIERPTVxucHJvdG8ucmVtb3ZlRWxlbSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGhpcy5lbGVtZW50ICk7XG4gIC8vIHJlbW92ZSBkaXNwbGF5OiBub25lXG4gIHRoaXMuY3NzKHsgZGlzcGxheTogJycgfSk7XG4gIHRoaXMuZW1pdEV2ZW50KCAncmVtb3ZlJywgWyB0aGlzIF0gKTtcbn07XG5cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBqdXN0IHJlbW92ZSBlbGVtZW50IGlmIG5vIHRyYW5zaXRpb24gc3VwcG9ydCBvciBubyB0cmFuc2l0aW9uXG4gIGlmICggIXRyYW5zaXRpb25Qcm9wZXJ0eSB8fCAhcGFyc2VGbG9hdCggdGhpcy5sYXlvdXQub3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb24gKSApIHtcbiAgICB0aGlzLnJlbW92ZUVsZW0oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzdGFydCB0cmFuc2l0aW9uXG4gIHRoaXMub25jZSggJ3RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUVsZW0oKTtcbiAgfSk7XG4gIHRoaXMuaGlkZSgpO1xufTtcblxucHJvdG8ucmV2ZWFsID0gZnVuY3Rpb24oKSB7XG4gIGRlbGV0ZSB0aGlzLmlzSGlkZGVuO1xuICAvLyByZW1vdmUgZGlzcGxheTogbm9uZVxuICB0aGlzLmNzcyh7IGRpc3BsYXk6ICcnIH0pO1xuXG4gIHZhciBvcHRpb25zID0gdGhpcy5sYXlvdXQub3B0aW9ucztcblxuICB2YXIgb25UcmFuc2l0aW9uRW5kID0ge307XG4gIHZhciB0cmFuc2l0aW9uRW5kUHJvcGVydHkgPSB0aGlzLmdldEhpZGVSZXZlYWxUcmFuc2l0aW9uRW5kUHJvcGVydHkoJ3Zpc2libGVTdHlsZScpO1xuICBvblRyYW5zaXRpb25FbmRbIHRyYW5zaXRpb25FbmRQcm9wZXJ0eSBdID0gdGhpcy5vblJldmVhbFRyYW5zaXRpb25FbmQ7XG5cbiAgdGhpcy50cmFuc2l0aW9uKHtcbiAgICBmcm9tOiBvcHRpb25zLmhpZGRlblN0eWxlLFxuICAgIHRvOiBvcHRpb25zLnZpc2libGVTdHlsZSxcbiAgICBpc0NsZWFuaW5nOiB0cnVlLFxuICAgIG9uVHJhbnNpdGlvbkVuZDogb25UcmFuc2l0aW9uRW5kXG4gIH0pO1xufTtcblxucHJvdG8ub25SZXZlYWxUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNoZWNrIGlmIHN0aWxsIHZpc2libGVcbiAgLy8gZHVyaW5nIHRyYW5zaXRpb24sIGl0ZW0gbWF5IGhhdmUgYmVlbiBoaWRkZW5cbiAgaWYgKCAhdGhpcy5pc0hpZGRlbiApIHtcbiAgICB0aGlzLmVtaXRFdmVudCgncmV2ZWFsJyk7XG4gIH1cbn07XG5cbi8qKlxuICogZ2V0IHN0eWxlIHByb3BlcnR5IHVzZSBmb3IgaGlkZS9yZXZlYWwgdHJhbnNpdGlvbiBlbmRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHlsZVByb3BlcnR5IC0gaGlkZGVuU3R5bGUvdmlzaWJsZVN0eWxlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5wcm90by5nZXRIaWRlUmV2ZWFsVHJhbnNpdGlvbkVuZFByb3BlcnR5ID0gZnVuY3Rpb24oIHN0eWxlUHJvcGVydHkgKSB7XG4gIHZhciBvcHRpb25TdHlsZSA9IHRoaXMubGF5b3V0Lm9wdGlvbnNbIHN0eWxlUHJvcGVydHkgXTtcbiAgLy8gdXNlIG9wYWNpdHlcbiAgaWYgKCBvcHRpb25TdHlsZS5vcGFjaXR5ICkge1xuICAgIHJldHVybiAnb3BhY2l0eSc7XG4gIH1cbiAgLy8gZ2V0IGZpcnN0IHByb3BlcnR5XG4gIGZvciAoIHZhciBwcm9wIGluIG9wdGlvblN0eWxlICkge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG5wcm90by5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNldCBmbGFnXG4gIHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xuICAvLyByZW1vdmUgZGlzcGxheTogbm9uZVxuICB0aGlzLmNzcyh7IGRpc3BsYXk6ICcnIH0pO1xuXG4gIHZhciBvcHRpb25zID0gdGhpcy5sYXlvdXQub3B0aW9ucztcblxuICB2YXIgb25UcmFuc2l0aW9uRW5kID0ge307XG4gIHZhciB0cmFuc2l0aW9uRW5kUHJvcGVydHkgPSB0aGlzLmdldEhpZGVSZXZlYWxUcmFuc2l0aW9uRW5kUHJvcGVydHkoJ2hpZGRlblN0eWxlJyk7XG4gIG9uVHJhbnNpdGlvbkVuZFsgdHJhbnNpdGlvbkVuZFByb3BlcnR5IF0gPSB0aGlzLm9uSGlkZVRyYW5zaXRpb25FbmQ7XG5cbiAgdGhpcy50cmFuc2l0aW9uKHtcbiAgICBmcm9tOiBvcHRpb25zLnZpc2libGVTdHlsZSxcbiAgICB0bzogb3B0aW9ucy5oaWRkZW5TdHlsZSxcbiAgICAvLyBrZWVwIGhpZGRlbiBzdHVmZiBoaWRkZW5cbiAgICBpc0NsZWFuaW5nOiB0cnVlLFxuICAgIG9uVHJhbnNpdGlvbkVuZDogb25UcmFuc2l0aW9uRW5kXG4gIH0pO1xufTtcblxucHJvdG8ub25IaWRlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKCkge1xuICAvLyBjaGVjayBpZiBzdGlsbCBoaWRkZW5cbiAgLy8gZHVyaW5nIHRyYW5zaXRpb24sIGl0ZW0gbWF5IGhhdmUgYmVlbiB1bi1oaWRkZW5cbiAgaWYgKCB0aGlzLmlzSGlkZGVuICkge1xuICAgIHRoaXMuY3NzKHsgZGlzcGxheTogJ25vbmUnIH0pO1xuICAgIHRoaXMuZW1pdEV2ZW50KCdoaWRlJyk7XG4gIH1cbn07XG5cbnByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jc3Moe1xuICAgIHBvc2l0aW9uOiAnJyxcbiAgICBsZWZ0OiAnJyxcbiAgICByaWdodDogJycsXG4gICAgdG9wOiAnJyxcbiAgICBib3R0b206ICcnLFxuICAgIHRyYW5zaXRpb246ICcnLFxuICAgIHRyYW5zZm9ybTogJydcbiAgfSk7XG59O1xuXG5yZXR1cm4gSXRlbTtcblxufSkpO1xuIl0sIm5hbWVzIjpbIndpbmRvdyIsImZhY3RvcnkiLCJkZWZpbmUiLCJhbWQiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIk91dGxheWVyIiwiSXRlbSIsIkV2RW1pdHRlciIsImdldFNpemUiLCJpc0VtcHR5T2JqIiwib2JqIiwicHJvcCIsImRvY0VsZW1TdHlsZSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJ0cmFuc2l0aW9uIiwidHJhbnNmb3JtUHJvcGVydHkiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJXZWJraXRUcmFuc2l0aW9uIiwidmVuZG9yUHJvcGVydGllcyIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25EZWxheSIsImVsZW1lbnQiLCJsYXlvdXQiLCJwb3NpdGlvbiIsIngiLCJ5IiwiX2NyZWF0ZSIsInByb3RvIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJfdHJhbnNuIiwiaW5nUHJvcGVydGllcyIsImNsZWFuIiwib25FbmQiLCJjc3MiLCJoYW5kbGVFdmVudCIsImV2ZW50IiwibWV0aG9kIiwidHlwZSIsInNpemUiLCJlbGVtU3R5bGUiLCJzdXBwb3J0ZWRQcm9wIiwiZ2V0UG9zaXRpb24iLCJnZXRDb21wdXRlZFN0eWxlIiwiaXNPcmlnaW5MZWZ0IiwiX2dldE9wdGlvbiIsImlzT3JpZ2luVG9wIiwieFZhbHVlIiwieVZhbHVlIiwicGFyc2VGbG9hdCIsImxheW91dFNpemUiLCJpbmRleE9mIiwid2lkdGgiLCJoZWlnaHQiLCJpc05hTiIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJsYXlvdXRQb3NpdGlvbiIsInhQYWRkaW5nIiwieFByb3BlcnR5IiwieFJlc2V0UHJvcGVydHkiLCJnZXRYVmFsdWUiLCJ5UGFkZGluZyIsInlQcm9wZXJ0eSIsInlSZXNldFByb3BlcnR5IiwiZ2V0WVZhbHVlIiwiZW1pdEV2ZW50IiwiaXNIb3Jpem9udGFsIiwib3B0aW9ucyIsInBlcmNlbnRQb3NpdGlvbiIsIl90cmFuc2l0aW9uVG8iLCJjdXJYIiwiY3VyWSIsImRpZE5vdE1vdmUiLCJzZXRQb3NpdGlvbiIsImlzVHJhbnNpdGlvbmluZyIsInRyYW5zWCIsInRyYW5zWSIsInRyYW5zaXRpb25TdHlsZSIsImdldFRyYW5zbGF0ZSIsInRvIiwib25UcmFuc2l0aW9uRW5kIiwiaXNDbGVhbmluZyIsImdvVG8iLCJtb3ZlVG8iLCJfbm9uVHJhbnNpdGlvbiIsImFyZ3MiLCJfcmVtb3ZlU3R5bGVzIiwiY2FsbCIsIl90cmFuc2l0aW9uIiwiZnJvbSIsImgiLCJvZmZzZXRIZWlnaHQiLCJlbmFibGVUcmFuc2l0aW9uIiwidG9EYXNoZWRBbGwiLCJzdHIiLCJyZXBsYWNlIiwiJDEiLCJ0b0xvd2VyQ2FzZSIsInRyYW5zaXRpb25Qcm9wcyIsImR1cmF0aW9uIiwic3RhZ2dlckRlbGF5IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9ud2Via2l0VHJhbnNpdGlvbkVuZCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ub3RyYW5zaXRpb25lbmQiLCJkYXNoZWRWZW5kb3JQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcGVydHlOYW1lIiwiZGlzYWJsZVRyYW5zaXRpb24iLCJyZW1vdmVUcmFuc2l0aW9uU3R5bGVzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsZWFuU3R5bGUiLCJjbGVhblRyYW5zaXRpb25TdHlsZSIsInN0YWdnZXIiLCJkZWxheSIsInJlbW92ZUVsZW0iLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJkaXNwbGF5IiwicmVtb3ZlIiwib25jZSIsImhpZGUiLCJyZXZlYWwiLCJpc0hpZGRlbiIsInRyYW5zaXRpb25FbmRQcm9wZXJ0eSIsImdldEhpZGVSZXZlYWxUcmFuc2l0aW9uRW5kUHJvcGVydHkiLCJvblJldmVhbFRyYW5zaXRpb25FbmQiLCJoaWRkZW5TdHlsZSIsInZpc2libGVTdHlsZSIsInN0eWxlUHJvcGVydHkiLCJvcHRpb25TdHlsZSIsIm9wYWNpdHkiLCJvbkhpZGVUcmFuc2l0aW9uRW5kIiwiZGVzdHJveSIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/outlayer/item.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/outlayer/outlayer.js":
/*!*******************************************!*\
  !*** ./node_modules/outlayer/outlayer.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*!\n * Outlayer v2.1.1\n * the brains and guts of a layout library\n * MIT license\n */ (function(window1, factory) {\n    \"use strict\";\n    // universal module definition\n    /* jshint strict: false */ /* globals define, module, require */ if (true) {\n        // AMD - RequireJS\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ev-emitter/ev-emitter */ \"(ssr)/./node_modules/ev-emitter/ev-emitter.js\"),\n            __webpack_require__(/*! get-size/get-size */ \"(ssr)/./node_modules/get-size/get-size.js\"),\n            __webpack_require__(/*! fizzy-ui-utils/utils */ \"(ssr)/./node_modules/fizzy-ui-utils/utils.js\"),\n            __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/outlayer/item.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(EvEmitter, getSize, utils, Item) {\n            return factory(window1, EvEmitter, getSize, utils, Item);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(window, function factory(window1, EvEmitter, getSize, utils, Item) {\n    \"use strict\";\n    // ----- vars ----- //\n    var console = window1.console;\n    var jQuery = window1.jQuery;\n    var noop = function() {};\n    // -------------------------- Outlayer -------------------------- //\n    // globally unique identifiers\n    var GUID = 0;\n    // internal store of all Outlayer intances\n    var instances = {};\n    /**\n * @param {Element, String} element\n * @param {Object} options\n * @constructor\n */ function Outlayer(element, options) {\n        var queryElement = utils.getQueryElement(element);\n        if (!queryElement) {\n            if (console) {\n                console.error(\"Bad element for \" + this.constructor.namespace + \": \" + (queryElement || element));\n            }\n            return;\n        }\n        this.element = queryElement;\n        // add jQuery\n        if (jQuery) {\n            this.$element = jQuery(this.element);\n        }\n        // options\n        this.options = utils.extend({}, this.constructor.defaults);\n        this.option(options);\n        // add id for Outlayer.getFromElement\n        var id = ++GUID;\n        this.element.outlayerGUID = id; // expando\n        instances[id] = this; // associate via id\n        // kick it off\n        this._create();\n        var isInitLayout = this._getOption(\"initLayout\");\n        if (isInitLayout) {\n            this.layout();\n        }\n    }\n    // settings are for internal use only\n    Outlayer.namespace = \"outlayer\";\n    Outlayer.Item = Item;\n    // default options\n    Outlayer.defaults = {\n        containerStyle: {\n            position: \"relative\"\n        },\n        initLayout: true,\n        originLeft: true,\n        originTop: true,\n        resize: true,\n        resizeContainer: true,\n        // item options\n        transitionDuration: \"0.4s\",\n        hiddenStyle: {\n            opacity: 0,\n            transform: \"scale(0.001)\"\n        },\n        visibleStyle: {\n            opacity: 1,\n            transform: \"scale(1)\"\n        }\n    };\n    var proto = Outlayer.prototype;\n    // inherit EvEmitter\n    utils.extend(proto, EvEmitter.prototype);\n    /**\n * set options\n * @param {Object} opts\n */ proto.option = function(opts) {\n        utils.extend(this.options, opts);\n    };\n    /**\n * get backwards compatible option value, check old name\n */ proto._getOption = function(option) {\n        var oldOption = this.constructor.compatOptions[option];\n        return oldOption && this.options[oldOption] !== undefined ? this.options[oldOption] : this.options[option];\n    };\n    Outlayer.compatOptions = {\n        // currentName: oldName\n        initLayout: \"isInitLayout\",\n        horizontal: \"isHorizontal\",\n        layoutInstant: \"isLayoutInstant\",\n        originLeft: \"isOriginLeft\",\n        originTop: \"isOriginTop\",\n        resize: \"isResizeBound\",\n        resizeContainer: \"isResizingContainer\"\n    };\n    proto._create = function() {\n        // get items from children\n        this.reloadItems();\n        // elements that affect layout, but are not laid out\n        this.stamps = [];\n        this.stamp(this.options.stamp);\n        // set container style\n        utils.extend(this.element.style, this.options.containerStyle);\n        // bind resize method\n        var canBindResize = this._getOption(\"resize\");\n        if (canBindResize) {\n            this.bindResize();\n        }\n    };\n    // goes through all children again and gets bricks in proper order\n    proto.reloadItems = function() {\n        // collection of item elements\n        this.items = this._itemize(this.element.children);\n    };\n    /**\n * turn elements into Outlayer.Items to be used in layout\n * @param {Array or NodeList or HTMLElement} elems\n * @returns {Array} items - collection of new Outlayer Items\n */ proto._itemize = function(elems) {\n        var itemElems = this._filterFindItemElements(elems);\n        var Item = this.constructor.Item;\n        // create new Outlayer Items for collection\n        var items = [];\n        for(var i = 0; i < itemElems.length; i++){\n            var elem = itemElems[i];\n            var item = new Item(elem, this);\n            items.push(item);\n        }\n        return items;\n    };\n    /**\n * get item elements to be used in layout\n * @param {Array or NodeList or HTMLElement} elems\n * @returns {Array} items - item elements\n */ proto._filterFindItemElements = function(elems) {\n        return utils.filterFindElements(elems, this.options.itemSelector);\n    };\n    /**\n * getter method for getting item elements\n * @returns {Array} elems - collection of item elements\n */ proto.getItemElements = function() {\n        return this.items.map(function(item) {\n            return item.element;\n        });\n    };\n    // ----- init & layout ----- //\n    /**\n * lays out all items\n */ proto.layout = function() {\n        this._resetLayout();\n        this._manageStamps();\n        // don't animate first layout\n        var layoutInstant = this._getOption(\"layoutInstant\");\n        var isInstant = layoutInstant !== undefined ? layoutInstant : !this._isLayoutInited;\n        this.layoutItems(this.items, isInstant);\n        // flag for initalized\n        this._isLayoutInited = true;\n    };\n    // _init is alias for layout\n    proto._init = proto.layout;\n    /**\n * logic before any new layout\n */ proto._resetLayout = function() {\n        this.getSize();\n    };\n    proto.getSize = function() {\n        this.size = getSize(this.element);\n    };\n    /**\n * get measurement from option, for columnWidth, rowHeight, gutter\n * if option is String -> get element from selector string, & get size of element\n * if option is Element -> get size of element\n * else use option as a number\n *\n * @param {String} measurement\n * @param {String} size - width or height\n * @private\n */ proto._getMeasurement = function(measurement, size) {\n        var option = this.options[measurement];\n        var elem;\n        if (!option) {\n            // default to 0\n            this[measurement] = 0;\n        } else {\n            // use option as an element\n            if (typeof option == \"string\") {\n                elem = this.element.querySelector(option);\n            } else if (option instanceof HTMLElement) {\n                elem = option;\n            }\n            // use size of element, if element\n            this[measurement] = elem ? getSize(elem)[size] : option;\n        }\n    };\n    /**\n * layout a collection of item elements\n * @api public\n */ proto.layoutItems = function(items, isInstant) {\n        items = this._getItemsForLayout(items);\n        this._layoutItems(items, isInstant);\n        this._postLayout();\n    };\n    /**\n * get the items to be laid out\n * you may want to skip over some items\n * @param {Array} items\n * @returns {Array} items\n */ proto._getItemsForLayout = function(items) {\n        return items.filter(function(item) {\n            return !item.isIgnored;\n        });\n    };\n    /**\n * layout items\n * @param {Array} items\n * @param {Boolean} isInstant\n */ proto._layoutItems = function(items, isInstant) {\n        this._emitCompleteOnItems(\"layout\", items);\n        if (!items || !items.length) {\n            // no items, emit event with empty array\n            return;\n        }\n        var queue = [];\n        items.forEach(function(item) {\n            // get x/y object from method\n            var position = this._getItemLayoutPosition(item);\n            // enqueue\n            position.item = item;\n            position.isInstant = isInstant || item.isLayoutInstant;\n            queue.push(position);\n        }, this);\n        this._processLayoutQueue(queue);\n    };\n    /**\n * get item layout position\n * @param {Outlayer.Item} item\n * @returns {Object} x and y position\n */ proto._getItemLayoutPosition = function() {\n        return {\n            x: 0,\n            y: 0\n        };\n    };\n    /**\n * iterate over array and position each item\n * Reason being - separating this logic prevents 'layout invalidation'\n * thx @paul_irish\n * @param {Array} queue\n */ proto._processLayoutQueue = function(queue) {\n        this.updateStagger();\n        queue.forEach(function(obj, i) {\n            this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);\n        }, this);\n    };\n    // set stagger from option in milliseconds number\n    proto.updateStagger = function() {\n        var stagger = this.options.stagger;\n        if (stagger === null || stagger === undefined) {\n            this.stagger = 0;\n            return;\n        }\n        this.stagger = getMilliseconds(stagger);\n        return this.stagger;\n    };\n    /**\n * Sets position of item in DOM\n * @param {Outlayer.Item} item\n * @param {Number} x - horizontal position\n * @param {Number} y - vertical position\n * @param {Boolean} isInstant - disables transitions\n */ proto._positionItem = function(item, x, y, isInstant, i) {\n        if (isInstant) {\n            // if not transition, just set CSS\n            item.goTo(x, y);\n        } else {\n            item.stagger(i * this.stagger);\n            item.moveTo(x, y);\n        }\n    };\n    /**\n * Any logic you want to do after each layout,\n * i.e. size the container\n */ proto._postLayout = function() {\n        this.resizeContainer();\n    };\n    proto.resizeContainer = function() {\n        var isResizingContainer = this._getOption(\"resizeContainer\");\n        if (!isResizingContainer) {\n            return;\n        }\n        var size = this._getContainerSize();\n        if (size) {\n            this._setContainerMeasure(size.width, true);\n            this._setContainerMeasure(size.height, false);\n        }\n    };\n    /**\n * Sets width or height of container if returned\n * @returns {Object} size\n *   @param {Number} width\n *   @param {Number} height\n */ proto._getContainerSize = noop;\n    /**\n * @param {Number} measure - size of width or height\n * @param {Boolean} isWidth\n */ proto._setContainerMeasure = function(measure, isWidth) {\n        if (measure === undefined) {\n            return;\n        }\n        var elemSize = this.size;\n        // add padding and border width if border box\n        if (elemSize.isBorderBox) {\n            measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight + elemSize.borderLeftWidth + elemSize.borderRightWidth : elemSize.paddingBottom + elemSize.paddingTop + elemSize.borderTopWidth + elemSize.borderBottomWidth;\n        }\n        measure = Math.max(measure, 0);\n        this.element.style[isWidth ? \"width\" : \"height\"] = measure + \"px\";\n    };\n    /**\n * emit eventComplete on a collection of items events\n * @param {String} eventName\n * @param {Array} items - Outlayer.Items\n */ proto._emitCompleteOnItems = function(eventName, items) {\n        var _this = this;\n        function onComplete() {\n            _this.dispatchEvent(eventName + \"Complete\", null, [\n                items\n            ]);\n        }\n        var count = items.length;\n        if (!items || !count) {\n            onComplete();\n            return;\n        }\n        var doneCount = 0;\n        function tick() {\n            doneCount++;\n            if (doneCount == count) {\n                onComplete();\n            }\n        }\n        // bind callback\n        items.forEach(function(item) {\n            item.once(eventName, tick);\n        });\n    };\n    /**\n * emits events via EvEmitter and jQuery events\n * @param {String} type - name of event\n * @param {Event} event - original event\n * @param {Array} args - extra arguments\n */ proto.dispatchEvent = function(type, event, args) {\n        // add original event to arguments\n        var emitArgs = event ? [\n            event\n        ].concat(args) : args;\n        this.emitEvent(type, emitArgs);\n        if (jQuery) {\n            // set this.$element\n            this.$element = this.$element || jQuery(this.element);\n            if (event) {\n                // create jQuery event\n                var $event = jQuery.Event(event);\n                $event.type = type;\n                this.$element.trigger($event, args);\n            } else {\n                // just trigger with type if no event available\n                this.$element.trigger(type, args);\n            }\n        }\n    };\n    // -------------------------- ignore & stamps -------------------------- //\n    /**\n * keep item in collection, but do not lay it out\n * ignored items do not get skipped in layout\n * @param {Element} elem\n */ proto.ignore = function(elem) {\n        var item = this.getItem(elem);\n        if (item) {\n            item.isIgnored = true;\n        }\n    };\n    /**\n * return item to layout collection\n * @param {Element} elem\n */ proto.unignore = function(elem) {\n        var item = this.getItem(elem);\n        if (item) {\n            delete item.isIgnored;\n        }\n    };\n    /**\n * adds elements to stamps\n * @param {NodeList, Array, Element, or String} elems\n */ proto.stamp = function(elems) {\n        elems = this._find(elems);\n        if (!elems) {\n            return;\n        }\n        this.stamps = this.stamps.concat(elems);\n        // ignore\n        elems.forEach(this.ignore, this);\n    };\n    /**\n * removes elements to stamps\n * @param {NodeList, Array, or Element} elems\n */ proto.unstamp = function(elems) {\n        elems = this._find(elems);\n        if (!elems) {\n            return;\n        }\n        elems.forEach(function(elem) {\n            // filter out removed stamp elements\n            utils.removeFrom(this.stamps, elem);\n            this.unignore(elem);\n        }, this);\n    };\n    /**\n * finds child elements\n * @param {NodeList, Array, Element, or String} elems\n * @returns {Array} elems\n */ proto._find = function(elems) {\n        if (!elems) {\n            return;\n        }\n        // if string, use argument as selector string\n        if (typeof elems == \"string\") {\n            elems = this.element.querySelectorAll(elems);\n        }\n        elems = utils.makeArray(elems);\n        return elems;\n    };\n    proto._manageStamps = function() {\n        if (!this.stamps || !this.stamps.length) {\n            return;\n        }\n        this._getBoundingRect();\n        this.stamps.forEach(this._manageStamp, this);\n    };\n    // update boundingLeft / Top\n    proto._getBoundingRect = function() {\n        // get bounding rect for container element\n        var boundingRect = this.element.getBoundingClientRect();\n        var size = this.size;\n        this._boundingRect = {\n            left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,\n            top: boundingRect.top + size.paddingTop + size.borderTopWidth,\n            right: boundingRect.right - (size.paddingRight + size.borderRightWidth),\n            bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)\n        };\n    };\n    /**\n * @param {Element} stamp\n**/ proto._manageStamp = noop;\n    /**\n * get x/y position of element relative to container element\n * @param {Element} elem\n * @returns {Object} offset - has left, top, right, bottom\n */ proto._getElementOffset = function(elem) {\n        var boundingRect = elem.getBoundingClientRect();\n        var thisRect = this._boundingRect;\n        var size = getSize(elem);\n        var offset = {\n            left: boundingRect.left - thisRect.left - size.marginLeft,\n            top: boundingRect.top - thisRect.top - size.marginTop,\n            right: thisRect.right - boundingRect.right - size.marginRight,\n            bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom\n        };\n        return offset;\n    };\n    // -------------------------- resize -------------------------- //\n    // enable event handlers for listeners\n    // i.e. resize -> onresize\n    proto.handleEvent = utils.handleEvent;\n    /**\n * Bind layout to window resizing\n */ proto.bindResize = function() {\n        window1.addEventListener(\"resize\", this);\n        this.isResizeBound = true;\n    };\n    /**\n * Unbind layout to window resizing\n */ proto.unbindResize = function() {\n        window1.removeEventListener(\"resize\", this);\n        this.isResizeBound = false;\n    };\n    proto.onresize = function() {\n        this.resize();\n    };\n    utils.debounceMethod(Outlayer, \"onresize\", 100);\n    proto.resize = function() {\n        // don't trigger if size did not change\n        // or if resize was unbound. See #9\n        if (!this.isResizeBound || !this.needsResizeLayout()) {\n            return;\n        }\n        this.layout();\n    };\n    /**\n * check if layout is needed post layout\n * @returns Boolean\n */ proto.needsResizeLayout = function() {\n        var size = getSize(this.element);\n        // check that this.size and size are there\n        // IE8 triggers resize on body size change, so they might not be\n        var hasSizes = this.size && size;\n        return hasSizes && size.innerWidth !== this.size.innerWidth;\n    };\n    // -------------------------- methods -------------------------- //\n    /**\n * add items to Outlayer instance\n * @param {Array or NodeList or Element} elems\n * @returns {Array} items - Outlayer.Items\n**/ proto.addItems = function(elems) {\n        var items = this._itemize(elems);\n        // add items to collection\n        if (items.length) {\n            this.items = this.items.concat(items);\n        }\n        return items;\n    };\n    /**\n * Layout newly-appended item elements\n * @param {Array or NodeList or Element} elems\n */ proto.appended = function(elems) {\n        var items = this.addItems(elems);\n        if (!items.length) {\n            return;\n        }\n        // layout and reveal just the new items\n        this.layoutItems(items, true);\n        this.reveal(items);\n    };\n    /**\n * Layout prepended elements\n * @param {Array or NodeList or Element} elems\n */ proto.prepended = function(elems) {\n        var items = this._itemize(elems);\n        if (!items.length) {\n            return;\n        }\n        // add items to beginning of collection\n        var previousItems = this.items.slice(0);\n        this.items = items.concat(previousItems);\n        // start new layout\n        this._resetLayout();\n        this._manageStamps();\n        // layout new stuff without transition\n        this.layoutItems(items, true);\n        this.reveal(items);\n        // layout previous items\n        this.layoutItems(previousItems);\n    };\n    /**\n * reveal a collection of items\n * @param {Array of Outlayer.Items} items\n */ proto.reveal = function(items) {\n        this._emitCompleteOnItems(\"reveal\", items);\n        if (!items || !items.length) {\n            return;\n        }\n        var stagger = this.updateStagger();\n        items.forEach(function(item, i) {\n            item.stagger(i * stagger);\n            item.reveal();\n        });\n    };\n    /**\n * hide a collection of items\n * @param {Array of Outlayer.Items} items\n */ proto.hide = function(items) {\n        this._emitCompleteOnItems(\"hide\", items);\n        if (!items || !items.length) {\n            return;\n        }\n        var stagger = this.updateStagger();\n        items.forEach(function(item, i) {\n            item.stagger(i * stagger);\n            item.hide();\n        });\n    };\n    /**\n * reveal item elements\n * @param {Array}, {Element}, {NodeList} items\n */ proto.revealItemElements = function(elems) {\n        var items = this.getItems(elems);\n        this.reveal(items);\n    };\n    /**\n * hide item elements\n * @param {Array}, {Element}, {NodeList} items\n */ proto.hideItemElements = function(elems) {\n        var items = this.getItems(elems);\n        this.hide(items);\n    };\n    /**\n * get Outlayer.Item, given an Element\n * @param {Element} elem\n * @param {Function} callback\n * @returns {Outlayer.Item} item\n */ proto.getItem = function(elem) {\n        // loop through items to get the one that matches\n        for(var i = 0; i < this.items.length; i++){\n            var item = this.items[i];\n            if (item.element == elem) {\n                // return item\n                return item;\n            }\n        }\n    };\n    /**\n * get collection of Outlayer.Items, given Elements\n * @param {Array} elems\n * @returns {Array} items - Outlayer.Items\n */ proto.getItems = function(elems) {\n        elems = utils.makeArray(elems);\n        var items = [];\n        elems.forEach(function(elem) {\n            var item = this.getItem(elem);\n            if (item) {\n                items.push(item);\n            }\n        }, this);\n        return items;\n    };\n    /**\n * remove element(s) from instance and DOM\n * @param {Array or NodeList or Element} elems\n */ proto.remove = function(elems) {\n        var removeItems = this.getItems(elems);\n        this._emitCompleteOnItems(\"remove\", removeItems);\n        // bail if no items to remove\n        if (!removeItems || !removeItems.length) {\n            return;\n        }\n        removeItems.forEach(function(item) {\n            item.remove();\n            // remove item from collection\n            utils.removeFrom(this.items, item);\n        }, this);\n    };\n    // ----- destroy ----- //\n    // remove and disable Outlayer instance\n    proto.destroy = function() {\n        // clean up dynamic styles\n        var style = this.element.style;\n        style.height = \"\";\n        style.position = \"\";\n        style.width = \"\";\n        // destroy items\n        this.items.forEach(function(item) {\n            item.destroy();\n        });\n        this.unbindResize();\n        var id = this.element.outlayerGUID;\n        delete instances[id]; // remove reference to instance by id\n        delete this.element.outlayerGUID;\n        // remove data for jQuery\n        if (jQuery) {\n            jQuery.removeData(this.element, this.constructor.namespace);\n        }\n    };\n    // -------------------------- data -------------------------- //\n    /**\n * get Outlayer instance from element\n * @param {Element} elem\n * @returns {Outlayer}\n */ Outlayer.data = function(elem) {\n        elem = utils.getQueryElement(elem);\n        var id = elem && elem.outlayerGUID;\n        return id && instances[id];\n    };\n    // -------------------------- create Outlayer class -------------------------- //\n    /**\n * create a layout class\n * @param {String} namespace\n */ Outlayer.create = function(namespace, options) {\n        // sub-class Outlayer\n        var Layout = subclass(Outlayer);\n        // apply new options and compatOptions\n        Layout.defaults = utils.extend({}, Outlayer.defaults);\n        utils.extend(Layout.defaults, options);\n        Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);\n        Layout.namespace = namespace;\n        Layout.data = Outlayer.data;\n        // sub-class Item\n        Layout.Item = subclass(Item);\n        // -------------------------- declarative -------------------------- //\n        utils.htmlInit(Layout, namespace);\n        // -------------------------- jQuery bridge -------------------------- //\n        // make into jQuery plugin\n        if (jQuery && jQuery.bridget) {\n            jQuery.bridget(namespace, Layout);\n        }\n        return Layout;\n    };\n    function subclass(Parent) {\n        function SubClass() {\n            Parent.apply(this, arguments);\n        }\n        SubClass.prototype = Object.create(Parent.prototype);\n        SubClass.prototype.constructor = SubClass;\n        return SubClass;\n    }\n    // ----- helpers ----- //\n    // how many milliseconds are in each unit\n    var msUnits = {\n        ms: 1,\n        s: 1000\n    };\n    // munge time-like parameter into millisecond number\n    // '0.4s' -> 40\n    function getMilliseconds(time) {\n        if (typeof time == \"number\") {\n            return time;\n        }\n        var matches = time.match(/(^\\d*\\.?\\d*)(\\w*)/);\n        var num = matches && matches[1];\n        var unit = matches && matches[2];\n        if (!num.length) {\n            return 0;\n        }\n        num = parseFloat(num);\n        var mult = msUnits[unit] || 1;\n        return num * mult;\n    }\n    // ----- fin ----- //\n    // back in global\n    Outlayer.Item = Item;\n    return Outlayer;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3V0bGF5ZXIvb3V0bGF5ZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7O0NBSUMsR0FFQyxVQUFVQSxPQUFNLEVBQUVDLE9BQU87SUFDekI7SUFDQSw4QkFBOEI7SUFDOUIsd0JBQXdCLEdBQUcsbUNBQW1DLEdBQzlELElBQUssSUFBeUMsRUFBRztRQUMvQyxrQkFBa0I7UUFDbEJDLGlDQUFRO1lBQ0o7WUFDQTtZQUNBO1lBQ0E7U0FDRCxtQ0FDRCxTQUFVRSxTQUFTLEVBQUVDLE9BQU8sRUFBRUMsS0FBSyxFQUFFQyxJQUFJO1lBQ3ZDLE9BQU9OLFFBQVNELFNBQVFJLFdBQVdDLFNBQVNDLE9BQU9DO1FBQ3JELENBQUM7QUFBQTtJQUVMLE9BQU8sRUFrQk47QUFFSCxHQUFHUCxRQUFRLFNBQVNDLFFBQVNELE9BQU0sRUFBRUksU0FBUyxFQUFFQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsSUFBSTtJQUNwRTtJQUVBLHNCQUFzQjtJQUV0QixJQUFJTSxVQUFVYixRQUFPYSxPQUFPO0lBQzVCLElBQUlDLFNBQVNkLFFBQU9jLE1BQU07SUFDMUIsSUFBSUMsT0FBTyxZQUFZO0lBRXZCLG9FQUFvRTtJQUVwRSw4QkFBOEI7SUFDOUIsSUFBSUMsT0FBTztJQUNYLDBDQUEwQztJQUMxQyxJQUFJQyxZQUFZLENBQUM7SUFHakI7Ozs7Q0FJQyxHQUNELFNBQVNOLFNBQVVPLE9BQU8sRUFBRUMsT0FBTztRQUNqQyxJQUFJQyxlQUFlZCxNQUFNZSxlQUFlLENBQUVIO1FBQzFDLElBQUssQ0FBQ0UsY0FBZTtZQUNuQixJQUFLUCxTQUFVO2dCQUNiQSxRQUFRUyxLQUFLLENBQUUscUJBQXFCLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxTQUFTLEdBQzVELE9BQVNKLENBQUFBLGdCQUFnQkYsT0FBTTtZQUNuQztZQUNBO1FBQ0Y7UUFDQSxJQUFJLENBQUNBLE9BQU8sR0FBR0U7UUFDZixhQUFhO1FBQ2IsSUFBS04sUUFBUztZQUNaLElBQUksQ0FB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T0EsUUFBUSxVQUFXO1lBQzdCLE9BQU9BO1FBQ1Q7UUFDQSxJQUFJQyxVQUFVRCxLQUFLRSxLQUFLLENBQUU7UUFDMUIsSUFBSUMsTUFBTUYsV0FBV0EsT0FBTyxDQUFDLEVBQUU7UUFDL0IsSUFBSUcsT0FBT0gsV0FBV0EsT0FBTyxDQUFDLEVBQUU7UUFDaEMsSUFBSyxDQUFDRSxJQUFJNUksTUFBTSxFQUFHO1lBQ2pCLE9BQU87UUFDVDtRQUNBNEksTUFBTUUsV0FBWUY7UUFDbEIsSUFBSUcsT0FBT1QsT0FBTyxDQUFFTyxLQUFNLElBQUk7UUFDOUIsT0FBT0QsTUFBTUc7SUFDZjtJQUVBLHFCQUFxQjtJQUVyQixpQkFBaUI7SUFDakJ4TSxTQUFTSixJQUFJLEdBQUdBO0lBRWhCLE9BQU9JO0FBRVAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmV0by1yZWFjdC8uL25vZGVfbW9kdWxlcy9vdXRsYXllci9vdXRsYXllci5qcz8zMjA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogT3V0bGF5ZXIgdjIuMS4xXG4gKiB0aGUgYnJhaW5zIGFuZCBndXRzIG9mIGEgbGF5b3V0IGxpYnJhcnlcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKiBnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EIC0gUmVxdWlyZUpTXG4gICAgZGVmaW5lKCBbXG4gICAgICAgICdldi1lbWl0dGVyL2V2LWVtaXR0ZXInLFxuICAgICAgICAnZ2V0LXNpemUvZ2V0LXNpemUnLFxuICAgICAgICAnZml6enktdWktdXRpbHMvdXRpbHMnLFxuICAgICAgICAnLi9pdGVtJ1xuICAgICAgXSxcbiAgICAgIGZ1bmN0aW9uKCBFdkVtaXR0ZXIsIGdldFNpemUsIHV0aWxzLCBJdGVtICkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIsIGdldFNpemUsIHV0aWxzLCBJdGVtKTtcbiAgICAgIH1cbiAgICApO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTIC0gQnJvd3NlcmlmeSwgV2VicGFja1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJ2V2LWVtaXR0ZXInKSxcbiAgICAgIHJlcXVpcmUoJ2dldC1zaXplJyksXG4gICAgICByZXF1aXJlKCdmaXp6eS11aS11dGlscycpLFxuICAgICAgcmVxdWlyZSgnLi9pdGVtJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93Lk91dGxheWVyID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5FdkVtaXR0ZXIsXG4gICAgICB3aW5kb3cuZ2V0U2l6ZSxcbiAgICAgIHdpbmRvdy5maXp6eVVJVXRpbHMsXG4gICAgICB3aW5kb3cuT3V0bGF5ZXIuSXRlbVxuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIEV2RW1pdHRlciwgZ2V0U2l6ZSwgdXRpbHMsIEl0ZW0gKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tIHZhcnMgLS0tLS0gLy9cblxudmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcbnZhciBqUXVlcnkgPSB3aW5kb3cualF1ZXJ5O1xudmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBPdXRsYXllciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBnbG9iYWxseSB1bmlxdWUgaWRlbnRpZmllcnNcbnZhciBHVUlEID0gMDtcbi8vIGludGVybmFsIHN0b3JlIG9mIGFsbCBPdXRsYXllciBpbnRhbmNlc1xudmFyIGluc3RhbmNlcyA9IHt9O1xuXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50LCBTdHJpbmd9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gT3V0bGF5ZXIoIGVsZW1lbnQsIG9wdGlvbnMgKSB7XG4gIHZhciBxdWVyeUVsZW1lbnQgPSB1dGlscy5nZXRRdWVyeUVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgaWYgKCAhcXVlcnlFbGVtZW50ICkge1xuICAgIGlmICggY29uc29sZSApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoICdCYWQgZWxlbWVudCBmb3IgJyArIHRoaXMuY29uc3RydWN0b3IubmFtZXNwYWNlICtcbiAgICAgICAgJzogJyArICggcXVlcnlFbGVtZW50IHx8IGVsZW1lbnQgKSApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5lbGVtZW50ID0gcXVlcnlFbGVtZW50O1xuICAvLyBhZGQgalF1ZXJ5XG4gIGlmICggalF1ZXJ5ICkge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBqUXVlcnkoIHRoaXMuZWxlbWVudCApO1xuICB9XG5cbiAgLy8gb3B0aW9uc1xuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoIHt9LCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzICk7XG4gIHRoaXMub3B0aW9uKCBvcHRpb25zICk7XG5cbiAgLy8gYWRkIGlkIGZvciBPdXRsYXllci5nZXRGcm9tRWxlbWVudFxuICB2YXIgaWQgPSArK0dVSUQ7XG4gIHRoaXMuZWxlbWVudC5vdXRsYXllckdVSUQgPSBpZDsgLy8gZXhwYW5kb1xuICBpbnN0YW5jZXNbIGlkIF0gPSB0aGlzOyAvLyBhc3NvY2lhdGUgdmlhIGlkXG5cbiAgLy8ga2ljayBpdCBvZmZcbiAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgdmFyIGlzSW5pdExheW91dCA9IHRoaXMuX2dldE9wdGlvbignaW5pdExheW91dCcpO1xuICBpZiAoIGlzSW5pdExheW91dCApIHtcbiAgICB0aGlzLmxheW91dCgpO1xuICB9XG59XG5cbi8vIHNldHRpbmdzIGFyZSBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbk91dGxheWVyLm5hbWVzcGFjZSA9ICdvdXRsYXllcic7XG5PdXRsYXllci5JdGVtID0gSXRlbTtcblxuLy8gZGVmYXVsdCBvcHRpb25zXG5PdXRsYXllci5kZWZhdWx0cyA9IHtcbiAgY29udGFpbmVyU3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICB9LFxuICBpbml0TGF5b3V0OiB0cnVlLFxuICBvcmlnaW5MZWZ0OiB0cnVlLFxuICBvcmlnaW5Ub3A6IHRydWUsXG4gIHJlc2l6ZTogdHJ1ZSxcbiAgcmVzaXplQ29udGFpbmVyOiB0cnVlLFxuICAvLyBpdGVtIG9wdGlvbnNcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiAnMC40cycsXG4gIGhpZGRlblN0eWxlOiB7XG4gICAgb3BhY2l0eTogMCxcbiAgICB0cmFuc2Zvcm06ICdzY2FsZSgwLjAwMSknXG4gIH0sXG4gIHZpc2libGVTdHlsZToge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknXG4gIH1cbn07XG5cbnZhciBwcm90byA9IE91dGxheWVyLnByb3RvdHlwZTtcbi8vIGluaGVyaXQgRXZFbWl0dGVyXG51dGlscy5leHRlbmQoIHByb3RvLCBFdkVtaXR0ZXIucHJvdG90eXBlICk7XG5cbi8qKlxuICogc2V0IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbnByb3RvLm9wdGlvbiA9IGZ1bmN0aW9uKCBvcHRzICkge1xuICB1dGlscy5leHRlbmQoIHRoaXMub3B0aW9ucywgb3B0cyApO1xufTtcblxuLyoqXG4gKiBnZXQgYmFja3dhcmRzIGNvbXBhdGlibGUgb3B0aW9uIHZhbHVlLCBjaGVjayBvbGQgbmFtZVxuICovXG5wcm90by5fZ2V0T3B0aW9uID0gZnVuY3Rpb24oIG9wdGlvbiApIHtcbiAgdmFyIG9sZE9wdGlvbiA9IHRoaXMuY29uc3RydWN0b3IuY29tcGF0T3B0aW9uc1sgb3B0aW9uIF07XG4gIHJldHVybiBvbGRPcHRpb24gJiYgdGhpcy5vcHRpb25zWyBvbGRPcHRpb24gXSAhPT0gdW5kZWZpbmVkID9cbiAgICB0aGlzLm9wdGlvbnNbIG9sZE9wdGlvbiBdIDogdGhpcy5vcHRpb25zWyBvcHRpb24gXTtcbn07XG5cbk91dGxheWVyLmNvbXBhdE9wdGlvbnMgPSB7XG4gIC8vIGN1cnJlbnROYW1lOiBvbGROYW1lXG4gIGluaXRMYXlvdXQ6ICdpc0luaXRMYXlvdXQnLFxuICBob3Jpem9udGFsOiAnaXNIb3Jpem9udGFsJyxcbiAgbGF5b3V0SW5zdGFudDogJ2lzTGF5b3V0SW5zdGFudCcsXG4gIG9yaWdpbkxlZnQ6ICdpc09yaWdpbkxlZnQnLFxuICBvcmlnaW5Ub3A6ICdpc09yaWdpblRvcCcsXG4gIHJlc2l6ZTogJ2lzUmVzaXplQm91bmQnLFxuICByZXNpemVDb250YWluZXI6ICdpc1Jlc2l6aW5nQ29udGFpbmVyJ1xufTtcblxucHJvdG8uX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBnZXQgaXRlbXMgZnJvbSBjaGlsZHJlblxuICB0aGlzLnJlbG9hZEl0ZW1zKCk7XG4gIC8vIGVsZW1lbnRzIHRoYXQgYWZmZWN0IGxheW91dCwgYnV0IGFyZSBub3QgbGFpZCBvdXRcbiAgdGhpcy5zdGFtcHMgPSBbXTtcbiAgdGhpcy5zdGFtcCggdGhpcy5vcHRpb25zLnN0YW1wICk7XG4gIC8vIHNldCBjb250YWluZXIgc3R5bGVcbiAgdXRpbHMuZXh0ZW5kKCB0aGlzLmVsZW1lbnQuc3R5bGUsIHRoaXMub3B0aW9ucy5jb250YWluZXJTdHlsZSApO1xuXG4gIC8vIGJpbmQgcmVzaXplIG1ldGhvZFxuICB2YXIgY2FuQmluZFJlc2l6ZSA9IHRoaXMuX2dldE9wdGlvbigncmVzaXplJyk7XG4gIGlmICggY2FuQmluZFJlc2l6ZSApIHtcbiAgICB0aGlzLmJpbmRSZXNpemUoKTtcbiAgfVxufTtcblxuLy8gZ29lcyB0aHJvdWdoIGFsbCBjaGlsZHJlbiBhZ2FpbiBhbmQgZ2V0cyBicmlja3MgaW4gcHJvcGVyIG9yZGVyXG5wcm90by5yZWxvYWRJdGVtcyA9IGZ1bmN0aW9uKCkge1xuICAvLyBjb2xsZWN0aW9uIG9mIGl0ZW0gZWxlbWVudHNcbiAgdGhpcy5pdGVtcyA9IHRoaXMuX2l0ZW1pemUoIHRoaXMuZWxlbWVudC5jaGlsZHJlbiApO1xufTtcblxuXG4vKipcbiAqIHR1cm4gZWxlbWVudHMgaW50byBPdXRsYXllci5JdGVtcyB0byBiZSB1c2VkIGluIGxheW91dFxuICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBIVE1MRWxlbWVudH0gZWxlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXMgLSBjb2xsZWN0aW9uIG9mIG5ldyBPdXRsYXllciBJdGVtc1xuICovXG5wcm90by5faXRlbWl6ZSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuICB2YXIgaXRlbUVsZW1zID0gdGhpcy5fZmlsdGVyRmluZEl0ZW1FbGVtZW50cyggZWxlbXMgKTtcbiAgdmFyIEl0ZW0gPSB0aGlzLmNvbnN0cnVjdG9yLkl0ZW07XG5cbiAgLy8gY3JlYXRlIG5ldyBPdXRsYXllciBJdGVtcyBmb3IgY29sbGVjdGlvblxuICB2YXIgaXRlbXMgPSBbXTtcbiAgZm9yICggdmFyIGk9MDsgaSA8IGl0ZW1FbGVtcy5sZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgZWxlbSA9IGl0ZW1FbGVtc1tpXTtcbiAgICB2YXIgaXRlbSA9IG5ldyBJdGVtKCBlbGVtLCB0aGlzICk7XG4gICAgaXRlbXMucHVzaCggaXRlbSApO1xuICB9XG5cbiAgcmV0dXJuIGl0ZW1zO1xufTtcblxuLyoqXG4gKiBnZXQgaXRlbSBlbGVtZW50cyB0byBiZSB1c2VkIGluIGxheW91dFxuICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBIVE1MRWxlbWVudH0gZWxlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXMgLSBpdGVtIGVsZW1lbnRzXG4gKi9cbnByb3RvLl9maWx0ZXJGaW5kSXRlbUVsZW1lbnRzID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICByZXR1cm4gdXRpbHMuZmlsdGVyRmluZEVsZW1lbnRzKCBlbGVtcywgdGhpcy5vcHRpb25zLml0ZW1TZWxlY3RvciApO1xufTtcblxuLyoqXG4gKiBnZXR0ZXIgbWV0aG9kIGZvciBnZXR0aW5nIGl0ZW0gZWxlbWVudHNcbiAqIEByZXR1cm5zIHtBcnJheX0gZWxlbXMgLSBjb2xsZWN0aW9uIG9mIGl0ZW0gZWxlbWVudHNcbiAqL1xucHJvdG8uZ2V0SXRlbUVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLml0ZW1zLm1hcCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgcmV0dXJuIGl0ZW0uZWxlbWVudDtcbiAgfSk7XG59O1xuXG4vLyAtLS0tLSBpbml0ICYgbGF5b3V0IC0tLS0tIC8vXG5cbi8qKlxuICogbGF5cyBvdXQgYWxsIGl0ZW1zXG4gKi9cbnByb3RvLmxheW91dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yZXNldExheW91dCgpO1xuICB0aGlzLl9tYW5hZ2VTdGFtcHMoKTtcblxuICAvLyBkb24ndCBhbmltYXRlIGZpcnN0IGxheW91dFxuICB2YXIgbGF5b3V0SW5zdGFudCA9IHRoaXMuX2dldE9wdGlvbignbGF5b3V0SW5zdGFudCcpO1xuICB2YXIgaXNJbnN0YW50ID0gbGF5b3V0SW5zdGFudCAhPT0gdW5kZWZpbmVkID9cbiAgICBsYXlvdXRJbnN0YW50IDogIXRoaXMuX2lzTGF5b3V0SW5pdGVkO1xuICB0aGlzLmxheW91dEl0ZW1zKCB0aGlzLml0ZW1zLCBpc0luc3RhbnQgKTtcblxuICAvLyBmbGFnIGZvciBpbml0YWxpemVkXG4gIHRoaXMuX2lzTGF5b3V0SW5pdGVkID0gdHJ1ZTtcbn07XG5cbi8vIF9pbml0IGlzIGFsaWFzIGZvciBsYXlvdXRcbnByb3RvLl9pbml0ID0gcHJvdG8ubGF5b3V0O1xuXG4vKipcbiAqIGxvZ2ljIGJlZm9yZSBhbnkgbmV3IGxheW91dFxuICovXG5wcm90by5fcmVzZXRMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nZXRTaXplKCk7XG59O1xuXG5cbnByb3RvLmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zaXplID0gZ2V0U2l6ZSggdGhpcy5lbGVtZW50ICk7XG59O1xuXG4vKipcbiAqIGdldCBtZWFzdXJlbWVudCBmcm9tIG9wdGlvbiwgZm9yIGNvbHVtbldpZHRoLCByb3dIZWlnaHQsIGd1dHRlclxuICogaWYgb3B0aW9uIGlzIFN0cmluZyAtPiBnZXQgZWxlbWVudCBmcm9tIHNlbGVjdG9yIHN0cmluZywgJiBnZXQgc2l6ZSBvZiBlbGVtZW50XG4gKiBpZiBvcHRpb24gaXMgRWxlbWVudCAtPiBnZXQgc2l6ZSBvZiBlbGVtZW50XG4gKiBlbHNlIHVzZSBvcHRpb24gYXMgYSBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVhc3VyZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gd2lkdGggb3IgaGVpZ2h0XG4gKiBAcHJpdmF0ZVxuICovXG5wcm90by5fZ2V0TWVhc3VyZW1lbnQgPSBmdW5jdGlvbiggbWVhc3VyZW1lbnQsIHNpemUgKSB7XG4gIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbnNbIG1lYXN1cmVtZW50IF07XG4gIHZhciBlbGVtO1xuICBpZiAoICFvcHRpb24gKSB7XG4gICAgLy8gZGVmYXVsdCB0byAwXG4gICAgdGhpc1sgbWVhc3VyZW1lbnQgXSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG9wdGlvbiBhcyBhbiBlbGVtZW50XG4gICAgaWYgKCB0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnICkge1xuICAgICAgZWxlbSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCBvcHRpb24gKTtcbiAgICB9IGVsc2UgaWYgKCBvcHRpb24gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCApIHtcbiAgICAgIGVsZW0gPSBvcHRpb247XG4gICAgfVxuICAgIC8vIHVzZSBzaXplIG9mIGVsZW1lbnQsIGlmIGVsZW1lbnRcbiAgICB0aGlzWyBtZWFzdXJlbWVudCBdID0gZWxlbSA/IGdldFNpemUoIGVsZW0gKVsgc2l6ZSBdIDogb3B0aW9uO1xuICB9XG59O1xuXG4vKipcbiAqIGxheW91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbSBlbGVtZW50c1xuICogQGFwaSBwdWJsaWNcbiAqL1xucHJvdG8ubGF5b3V0SXRlbXMgPSBmdW5jdGlvbiggaXRlbXMsIGlzSW5zdGFudCApIHtcbiAgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0ZvckxheW91dCggaXRlbXMgKTtcblxuICB0aGlzLl9sYXlvdXRJdGVtcyggaXRlbXMsIGlzSW5zdGFudCApO1xuXG4gIHRoaXMuX3Bvc3RMYXlvdXQoKTtcbn07XG5cbi8qKlxuICogZ2V0IHRoZSBpdGVtcyB0byBiZSBsYWlkIG91dFxuICogeW91IG1heSB3YW50IHRvIHNraXAgb3ZlciBzb21lIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICogQHJldHVybnMge0FycmF5fSBpdGVtc1xuICovXG5wcm90by5fZ2V0SXRlbXNGb3JMYXlvdXQgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG4gIHJldHVybiBpdGVtcy5maWx0ZXIoIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIHJldHVybiAhaXRlbS5pc0lnbm9yZWQ7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBsYXlvdXQgaXRlbXNcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW5zdGFudFxuICovXG5wcm90by5fbGF5b3V0SXRlbXMgPSBmdW5jdGlvbiggaXRlbXMsIGlzSW5zdGFudCApIHtcbiAgdGhpcy5fZW1pdENvbXBsZXRlT25JdGVtcyggJ2xheW91dCcsIGl0ZW1zICk7XG5cbiAgaWYgKCAhaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCApIHtcbiAgICAvLyBubyBpdGVtcywgZW1pdCBldmVudCB3aXRoIGVtcHR5IGFycmF5XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHF1ZXVlID0gW107XG5cbiAgaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgLy8gZ2V0IHgveSBvYmplY3QgZnJvbSBtZXRob2RcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9nZXRJdGVtTGF5b3V0UG9zaXRpb24oIGl0ZW0gKTtcbiAgICAvLyBlbnF1ZXVlXG4gICAgcG9zaXRpb24uaXRlbSA9IGl0ZW07XG4gICAgcG9zaXRpb24uaXNJbnN0YW50ID0gaXNJbnN0YW50IHx8IGl0ZW0uaXNMYXlvdXRJbnN0YW50O1xuICAgIHF1ZXVlLnB1c2goIHBvc2l0aW9uICk7XG4gIH0sIHRoaXMgKTtcblxuICB0aGlzLl9wcm9jZXNzTGF5b3V0UXVldWUoIHF1ZXVlICk7XG59O1xuXG4vKipcbiAqIGdldCBpdGVtIGxheW91dCBwb3NpdGlvblxuICogQHBhcmFtIHtPdXRsYXllci5JdGVtfSBpdGVtXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB4IGFuZCB5IHBvc2l0aW9uXG4gKi9cbnByb3RvLl9nZXRJdGVtTGF5b3V0UG9zaXRpb24gPSBmdW5jdGlvbiggLyogaXRlbSAqLyApIHtcbiAgcmV0dXJuIHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbn07XG5cbi8qKlxuICogaXRlcmF0ZSBvdmVyIGFycmF5IGFuZCBwb3NpdGlvbiBlYWNoIGl0ZW1cbiAqIFJlYXNvbiBiZWluZyAtIHNlcGFyYXRpbmcgdGhpcyBsb2dpYyBwcmV2ZW50cyAnbGF5b3V0IGludmFsaWRhdGlvbidcbiAqIHRoeCBAcGF1bF9pcmlzaFxuICogQHBhcmFtIHtBcnJheX0gcXVldWVcbiAqL1xucHJvdG8uX3Byb2Nlc3NMYXlvdXRRdWV1ZSA9IGZ1bmN0aW9uKCBxdWV1ZSApIHtcbiAgdGhpcy51cGRhdGVTdGFnZ2VyKCk7XG4gIHF1ZXVlLmZvckVhY2goIGZ1bmN0aW9uKCBvYmosIGkgKSB7XG4gICAgdGhpcy5fcG9zaXRpb25JdGVtKCBvYmouaXRlbSwgb2JqLngsIG9iai55LCBvYmouaXNJbnN0YW50LCBpICk7XG4gIH0sIHRoaXMgKTtcbn07XG5cbi8vIHNldCBzdGFnZ2VyIGZyb20gb3B0aW9uIGluIG1pbGxpc2Vjb25kcyBudW1iZXJcbnByb3RvLnVwZGF0ZVN0YWdnZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YWdnZXIgPSB0aGlzLm9wdGlvbnMuc3RhZ2dlcjtcbiAgaWYgKCBzdGFnZ2VyID09PSBudWxsIHx8IHN0YWdnZXIgPT09IHVuZGVmaW5lZCApIHtcbiAgICB0aGlzLnN0YWdnZXIgPSAwO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnN0YWdnZXIgPSBnZXRNaWxsaXNlY29uZHMoIHN0YWdnZXIgKTtcbiAgcmV0dXJuIHRoaXMuc3RhZ2dlcjtcbn07XG5cbi8qKlxuICogU2V0cyBwb3NpdGlvbiBvZiBpdGVtIGluIERPTVxuICogQHBhcmFtIHtPdXRsYXllci5JdGVtfSBpdGVtXG4gKiBAcGFyYW0ge051bWJlcn0geCAtIGhvcml6b250YWwgcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gdmVydGljYWwgcG9zaXRpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbnN0YW50IC0gZGlzYWJsZXMgdHJhbnNpdGlvbnNcbiAqL1xucHJvdG8uX3Bvc2l0aW9uSXRlbSA9IGZ1bmN0aW9uKCBpdGVtLCB4LCB5LCBpc0luc3RhbnQsIGkgKSB7XG4gIGlmICggaXNJbnN0YW50ICkge1xuICAgIC8vIGlmIG5vdCB0cmFuc2l0aW9uLCBqdXN0IHNldCBDU1NcbiAgICBpdGVtLmdvVG8oIHgsIHkgKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtLnN0YWdnZXIoIGkgKiB0aGlzLnN0YWdnZXIgKTtcbiAgICBpdGVtLm1vdmVUbyggeCwgeSApO1xuICB9XG59O1xuXG4vKipcbiAqIEFueSBsb2dpYyB5b3Ugd2FudCB0byBkbyBhZnRlciBlYWNoIGxheW91dCxcbiAqIGkuZS4gc2l6ZSB0aGUgY29udGFpbmVyXG4gKi9cbnByb3RvLl9wb3N0TGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVzaXplQ29udGFpbmVyKCk7XG59O1xuXG5wcm90by5yZXNpemVDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlzUmVzaXppbmdDb250YWluZXIgPSB0aGlzLl9nZXRPcHRpb24oJ3Jlc2l6ZUNvbnRhaW5lcicpO1xuICBpZiAoICFpc1Jlc2l6aW5nQ29udGFpbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2l6ZSA9IHRoaXMuX2dldENvbnRhaW5lclNpemUoKTtcbiAgaWYgKCBzaXplICkge1xuICAgIHRoaXMuX3NldENvbnRhaW5lck1lYXN1cmUoIHNpemUud2lkdGgsIHRydWUgKTtcbiAgICB0aGlzLl9zZXRDb250YWluZXJNZWFzdXJlKCBzaXplLmhlaWdodCwgZmFsc2UgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHdpZHRoIG9yIGhlaWdodCBvZiBjb250YWluZXIgaWYgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IHNpemVcbiAqICAgQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gKiAgIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqL1xucHJvdG8uX2dldENvbnRhaW5lclNpemUgPSBub29wO1xuXG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSBtZWFzdXJlIC0gc2l6ZSBvZiB3aWR0aCBvciBoZWlnaHRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNXaWR0aFxuICovXG5wcm90by5fc2V0Q29udGFpbmVyTWVhc3VyZSA9IGZ1bmN0aW9uKCBtZWFzdXJlLCBpc1dpZHRoICkge1xuICBpZiAoIG1lYXN1cmUgPT09IHVuZGVmaW5lZCApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZWxlbVNpemUgPSB0aGlzLnNpemU7XG4gIC8vIGFkZCBwYWRkaW5nIGFuZCBib3JkZXIgd2lkdGggaWYgYm9yZGVyIGJveFxuICBpZiAoIGVsZW1TaXplLmlzQm9yZGVyQm94ICkge1xuICAgIG1lYXN1cmUgKz0gaXNXaWR0aCA/IGVsZW1TaXplLnBhZGRpbmdMZWZ0ICsgZWxlbVNpemUucGFkZGluZ1JpZ2h0ICtcbiAgICAgIGVsZW1TaXplLmJvcmRlckxlZnRXaWR0aCArIGVsZW1TaXplLmJvcmRlclJpZ2h0V2lkdGggOlxuICAgICAgZWxlbVNpemUucGFkZGluZ0JvdHRvbSArIGVsZW1TaXplLnBhZGRpbmdUb3AgK1xuICAgICAgZWxlbVNpemUuYm9yZGVyVG9wV2lkdGggKyBlbGVtU2l6ZS5ib3JkZXJCb3R0b21XaWR0aDtcbiAgfVxuXG4gIG1lYXN1cmUgPSBNYXRoLm1heCggbWVhc3VyZSwgMCApO1xuICB0aGlzLmVsZW1lbnQuc3R5bGVbIGlzV2lkdGggPyAnd2lkdGgnIDogJ2hlaWdodCcgXSA9IG1lYXN1cmUgKyAncHgnO1xufTtcblxuLyoqXG4gKiBlbWl0IGV2ZW50Q29tcGxldGUgb24gYSBjb2xsZWN0aW9uIG9mIGl0ZW1zIGV2ZW50c1xuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICogQHBhcmFtIHtBcnJheX0gaXRlbXMgLSBPdXRsYXllci5JdGVtc1xuICovXG5wcm90by5fZW1pdENvbXBsZXRlT25JdGVtcyA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGl0ZW1zICkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoIGV2ZW50TmFtZSArICdDb21wbGV0ZScsIG51bGwsIFsgaXRlbXMgXSApO1xuICB9XG5cbiAgdmFyIGNvdW50ID0gaXRlbXMubGVuZ3RoO1xuICBpZiAoICFpdGVtcyB8fCAhY291bnQgKSB7XG4gICAgb25Db21wbGV0ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkb25lQ291bnQgPSAwO1xuICBmdW5jdGlvbiB0aWNrKCkge1xuICAgIGRvbmVDb3VudCsrO1xuICAgIGlmICggZG9uZUNvdW50ID09IGNvdW50ICkge1xuICAgICAgb25Db21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGJpbmQgY2FsbGJhY2tcbiAgaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgaXRlbS5vbmNlKCBldmVudE5hbWUsIHRpY2sgKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIGVtaXRzIGV2ZW50cyB2aWEgRXZFbWl0dGVyIGFuZCBqUXVlcnkgZXZlbnRzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIG5hbWUgb2YgZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gb3JpZ2luYWwgZXZlbnRcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBleHRyYSBhcmd1bWVudHNcbiAqL1xucHJvdG8uZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgYXJncyApIHtcbiAgLy8gYWRkIG9yaWdpbmFsIGV2ZW50IHRvIGFyZ3VtZW50c1xuICB2YXIgZW1pdEFyZ3MgPSBldmVudCA/IFsgZXZlbnQgXS5jb25jYXQoIGFyZ3MgKSA6IGFyZ3M7XG4gIHRoaXMuZW1pdEV2ZW50KCB0eXBlLCBlbWl0QXJncyApO1xuXG4gIGlmICggalF1ZXJ5ICkge1xuICAgIC8vIHNldCB0aGlzLiRlbGVtZW50XG4gICAgdGhpcy4kZWxlbWVudCA9IHRoaXMuJGVsZW1lbnQgfHwgalF1ZXJ5KCB0aGlzLmVsZW1lbnQgKTtcbiAgICBpZiAoIGV2ZW50ICkge1xuICAgICAgLy8gY3JlYXRlIGpRdWVyeSBldmVudFxuICAgICAgdmFyICRldmVudCA9IGpRdWVyeS5FdmVudCggZXZlbnQgKTtcbiAgICAgICRldmVudC50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlciggJGV2ZW50LCBhcmdzICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGp1c3QgdHJpZ2dlciB3aXRoIHR5cGUgaWYgbm8gZXZlbnQgYXZhaWxhYmxlXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoIHR5cGUsIGFyZ3MgKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGlnbm9yZSAmIHN0YW1wcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5cbi8qKlxuICoga2VlcCBpdGVtIGluIGNvbGxlY3Rpb24sIGJ1dCBkbyBub3QgbGF5IGl0IG91dFxuICogaWdub3JlZCBpdGVtcyBkbyBub3QgZ2V0IHNraXBwZWQgaW4gbGF5b3V0XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqL1xucHJvdG8uaWdub3JlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKCBlbGVtICk7XG4gIGlmICggaXRlbSApIHtcbiAgICBpdGVtLmlzSWdub3JlZCA9IHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogcmV0dXJuIGl0ZW0gdG8gbGF5b3V0IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICovXG5wcm90by51bmlnbm9yZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbSggZWxlbSApO1xuICBpZiAoIGl0ZW0gKSB7XG4gICAgZGVsZXRlIGl0ZW0uaXNJZ25vcmVkO1xuICB9XG59O1xuXG4vKipcbiAqIGFkZHMgZWxlbWVudHMgdG8gc3RhbXBzXG4gKiBAcGFyYW0ge05vZGVMaXN0LCBBcnJheSwgRWxlbWVudCwgb3IgU3RyaW5nfSBlbGVtc1xuICovXG5wcm90by5zdGFtcCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgZWxlbXMgPSB0aGlzLl9maW5kKCBlbGVtcyApO1xuICBpZiAoICFlbGVtcyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnN0YW1wcyA9IHRoaXMuc3RhbXBzLmNvbmNhdCggZWxlbXMgKTtcbiAgLy8gaWdub3JlXG4gIGVsZW1zLmZvckVhY2goIHRoaXMuaWdub3JlLCB0aGlzICk7XG59O1xuXG4vKipcbiAqIHJlbW92ZXMgZWxlbWVudHMgdG8gc3RhbXBzXG4gKiBAcGFyYW0ge05vZGVMaXN0LCBBcnJheSwgb3IgRWxlbWVudH0gZWxlbXNcbiAqL1xucHJvdG8udW5zdGFtcCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgZWxlbXMgPSB0aGlzLl9maW5kKCBlbGVtcyApO1xuICBpZiAoICFlbGVtcyApe1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgIC8vIGZpbHRlciBvdXQgcmVtb3ZlZCBzdGFtcCBlbGVtZW50c1xuICAgIHV0aWxzLnJlbW92ZUZyb20oIHRoaXMuc3RhbXBzLCBlbGVtICk7XG4gICAgdGhpcy51bmlnbm9yZSggZWxlbSApO1xuICB9LCB0aGlzICk7XG59O1xuXG4vKipcbiAqIGZpbmRzIGNoaWxkIGVsZW1lbnRzXG4gKiBAcGFyYW0ge05vZGVMaXN0LCBBcnJheSwgRWxlbWVudCwgb3IgU3RyaW5nfSBlbGVtc1xuICogQHJldHVybnMge0FycmF5fSBlbGVtc1xuICovXG5wcm90by5fZmluZCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgaWYgKCAhZWxlbXMgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGlmIHN0cmluZywgdXNlIGFyZ3VtZW50IGFzIHNlbGVjdG9yIHN0cmluZ1xuICBpZiAoIHR5cGVvZiBlbGVtcyA9PSAnc3RyaW5nJyApIHtcbiAgICBlbGVtcyA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCBlbGVtcyApO1xuICB9XG4gIGVsZW1zID0gdXRpbHMubWFrZUFycmF5KCBlbGVtcyApO1xuICByZXR1cm4gZWxlbXM7XG59O1xuXG5wcm90by5fbWFuYWdlU3RhbXBzID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMuc3RhbXBzIHx8ICF0aGlzLnN0YW1wcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fZ2V0Qm91bmRpbmdSZWN0KCk7XG5cbiAgdGhpcy5zdGFtcHMuZm9yRWFjaCggdGhpcy5fbWFuYWdlU3RhbXAsIHRoaXMgKTtcbn07XG5cbi8vIHVwZGF0ZSBib3VuZGluZ0xlZnQgLyBUb3BcbnByb3RvLl9nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbigpIHtcbiAgLy8gZ2V0IGJvdW5kaW5nIHJlY3QgZm9yIGNvbnRhaW5lciBlbGVtZW50XG4gIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzaXplID0gdGhpcy5zaXplO1xuICB0aGlzLl9ib3VuZGluZ1JlY3QgPSB7XG4gICAgbGVmdDogYm91bmRpbmdSZWN0LmxlZnQgKyBzaXplLnBhZGRpbmdMZWZ0ICsgc2l6ZS5ib3JkZXJMZWZ0V2lkdGgsXG4gICAgdG9wOiBib3VuZGluZ1JlY3QudG9wICsgc2l6ZS5wYWRkaW5nVG9wICsgc2l6ZS5ib3JkZXJUb3BXaWR0aCxcbiAgICByaWdodDogYm91bmRpbmdSZWN0LnJpZ2h0IC0gKCBzaXplLnBhZGRpbmdSaWdodCArIHNpemUuYm9yZGVyUmlnaHRXaWR0aCApLFxuICAgIGJvdHRvbTogYm91bmRpbmdSZWN0LmJvdHRvbSAtICggc2l6ZS5wYWRkaW5nQm90dG9tICsgc2l6ZS5ib3JkZXJCb3R0b21XaWR0aCApXG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gc3RhbXBcbioqL1xucHJvdG8uX21hbmFnZVN0YW1wID0gbm9vcDtcblxuLyoqXG4gKiBnZXQgeC95IHBvc2l0aW9uIG9mIGVsZW1lbnQgcmVsYXRpdmUgdG8gY29udGFpbmVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHJldHVybnMge09iamVjdH0gb2Zmc2V0IC0gaGFzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICovXG5wcm90by5fZ2V0RWxlbWVudE9mZnNldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB2YXIgYm91bmRpbmdSZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHRoaXNSZWN0ID0gdGhpcy5fYm91bmRpbmdSZWN0O1xuICB2YXIgc2l6ZSA9IGdldFNpemUoIGVsZW0gKTtcbiAgdmFyIG9mZnNldCA9IHtcbiAgICBsZWZ0OiBib3VuZGluZ1JlY3QubGVmdCAtIHRoaXNSZWN0LmxlZnQgLSBzaXplLm1hcmdpbkxlZnQsXG4gICAgdG9wOiBib3VuZGluZ1JlY3QudG9wIC0gdGhpc1JlY3QudG9wIC0gc2l6ZS5tYXJnaW5Ub3AsXG4gICAgcmlnaHQ6IHRoaXNSZWN0LnJpZ2h0IC0gYm91bmRpbmdSZWN0LnJpZ2h0IC0gc2l6ZS5tYXJnaW5SaWdodCxcbiAgICBib3R0b206IHRoaXNSZWN0LmJvdHRvbSAtIGJvdW5kaW5nUmVjdC5ib3R0b20gLSBzaXplLm1hcmdpbkJvdHRvbVxuICB9O1xuICByZXR1cm4gb2Zmc2V0O1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gcmVzaXplIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8vIGVuYWJsZSBldmVudCBoYW5kbGVycyBmb3IgbGlzdGVuZXJzXG4vLyBpLmUuIHJlc2l6ZSAtPiBvbnJlc2l6ZVxucHJvdG8uaGFuZGxlRXZlbnQgPSB1dGlscy5oYW5kbGVFdmVudDtcblxuLyoqXG4gKiBCaW5kIGxheW91dCB0byB3aW5kb3cgcmVzaXppbmdcbiAqL1xucHJvdG8uYmluZFJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3Jlc2l6ZScsIHRoaXMgKTtcbiAgdGhpcy5pc1Jlc2l6ZUJvdW5kID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogVW5iaW5kIGxheW91dCB0byB3aW5kb3cgcmVzaXppbmdcbiAqL1xucHJvdG8udW5iaW5kUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAncmVzaXplJywgdGhpcyApO1xuICB0aGlzLmlzUmVzaXplQm91bmQgPSBmYWxzZTtcbn07XG5cbnByb3RvLm9ucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVzaXplKCk7XG59O1xuXG51dGlscy5kZWJvdW5jZU1ldGhvZCggT3V0bGF5ZXIsICdvbnJlc2l6ZScsIDEwMCApO1xuXG5wcm90by5yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgLy8gZG9uJ3QgdHJpZ2dlciBpZiBzaXplIGRpZCBub3QgY2hhbmdlXG4gIC8vIG9yIGlmIHJlc2l6ZSB3YXMgdW5ib3VuZC4gU2VlICM5XG4gIGlmICggIXRoaXMuaXNSZXNpemVCb3VuZCB8fCAhdGhpcy5uZWVkc1Jlc2l6ZUxheW91dCgpICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMubGF5b3V0KCk7XG59O1xuXG4vKipcbiAqIGNoZWNrIGlmIGxheW91dCBpcyBuZWVkZWQgcG9zdCBsYXlvdXRcbiAqIEByZXR1cm5zIEJvb2xlYW5cbiAqL1xucHJvdG8ubmVlZHNSZXNpemVMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSBnZXRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbiAgLy8gY2hlY2sgdGhhdCB0aGlzLnNpemUgYW5kIHNpemUgYXJlIHRoZXJlXG4gIC8vIElFOCB0cmlnZ2VycyByZXNpemUgb24gYm9keSBzaXplIGNoYW5nZSwgc28gdGhleSBtaWdodCBub3QgYmVcbiAgdmFyIGhhc1NpemVzID0gdGhpcy5zaXplICYmIHNpemU7XG4gIHJldHVybiBoYXNTaXplcyAmJiBzaXplLmlubmVyV2lkdGggIT09IHRoaXMuc2l6ZS5pbm5lcldpZHRoO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIGFkZCBpdGVtcyB0byBPdXRsYXllciBpbnN0YW5jZVxuICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBFbGVtZW50fSBlbGVtc1xuICogQHJldHVybnMge0FycmF5fSBpdGVtcyAtIE91dGxheWVyLkl0ZW1zXG4qKi9cbnByb3RvLmFkZEl0ZW1zID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgaXRlbXMgPSB0aGlzLl9pdGVtaXplKCBlbGVtcyApO1xuICAvLyBhZGQgaXRlbXMgdG8gY29sbGVjdGlvblxuICBpZiAoIGl0ZW1zLmxlbmd0aCApIHtcbiAgICB0aGlzLml0ZW1zID0gdGhpcy5pdGVtcy5jb25jYXQoIGl0ZW1zICk7XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgbmV3bHktYXBwZW5kZWQgaXRlbSBlbGVtZW50c1xuICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBFbGVtZW50fSBlbGVtc1xuICovXG5wcm90by5hcHBlbmRlZCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgdmFyIGl0ZW1zID0gdGhpcy5hZGRJdGVtcyggZWxlbXMgKTtcbiAgaWYgKCAhaXRlbXMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBsYXlvdXQgYW5kIHJldmVhbCBqdXN0IHRoZSBuZXcgaXRlbXNcbiAgdGhpcy5sYXlvdXRJdGVtcyggaXRlbXMsIHRydWUgKTtcbiAgdGhpcy5yZXZlYWwoIGl0ZW1zICk7XG59O1xuXG4vKipcbiAqIExheW91dCBwcmVwZW5kZWQgZWxlbWVudHNcbiAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgRWxlbWVudH0gZWxlbXNcbiAqL1xucHJvdG8ucHJlcGVuZGVkID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgaXRlbXMgPSB0aGlzLl9pdGVtaXplKCBlbGVtcyApO1xuICBpZiAoICFpdGVtcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGFkZCBpdGVtcyB0byBiZWdpbm5pbmcgb2YgY29sbGVjdGlvblxuICB2YXIgcHJldmlvdXNJdGVtcyA9IHRoaXMuaXRlbXMuc2xpY2UoMCk7XG4gIHRoaXMuaXRlbXMgPSBpdGVtcy5jb25jYXQoIHByZXZpb3VzSXRlbXMgKTtcbiAgLy8gc3RhcnQgbmV3IGxheW91dFxuICB0aGlzLl9yZXNldExheW91dCgpO1xuICB0aGlzLl9tYW5hZ2VTdGFtcHMoKTtcbiAgLy8gbGF5b3V0IG5ldyBzdHVmZiB3aXRob3V0IHRyYW5zaXRpb25cbiAgdGhpcy5sYXlvdXRJdGVtcyggaXRlbXMsIHRydWUgKTtcbiAgdGhpcy5yZXZlYWwoIGl0ZW1zICk7XG4gIC8vIGxheW91dCBwcmV2aW91cyBpdGVtc1xuICB0aGlzLmxheW91dEl0ZW1zKCBwcmV2aW91c0l0ZW1zICk7XG59O1xuXG4vKipcbiAqIHJldmVhbCBhIGNvbGxlY3Rpb24gb2YgaXRlbXNcbiAqIEBwYXJhbSB7QXJyYXkgb2YgT3V0bGF5ZXIuSXRlbXN9IGl0ZW1zXG4gKi9cbnByb3RvLnJldmVhbCA9IGZ1bmN0aW9uKCBpdGVtcyApIHtcbiAgdGhpcy5fZW1pdENvbXBsZXRlT25JdGVtcyggJ3JldmVhbCcsIGl0ZW1zICk7XG4gIGlmICggIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzdGFnZ2VyID0gdGhpcy51cGRhdGVTdGFnZ2VyKCk7XG4gIGl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtLCBpICkge1xuICAgIGl0ZW0uc3RhZ2dlciggaSAqIHN0YWdnZXIgKTtcbiAgICBpdGVtLnJldmVhbCgpO1xuICB9KTtcbn07XG5cbi8qKlxuICogaGlkZSBhIGNvbGxlY3Rpb24gb2YgaXRlbXNcbiAqIEBwYXJhbSB7QXJyYXkgb2YgT3V0bGF5ZXIuSXRlbXN9IGl0ZW1zXG4gKi9cbnByb3RvLmhpZGUgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG4gIHRoaXMuX2VtaXRDb21wbGV0ZU9uSXRlbXMoICdoaWRlJywgaXRlbXMgKTtcbiAgaWYgKCAhaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHN0YWdnZXIgPSB0aGlzLnVwZGF0ZVN0YWdnZXIoKTtcbiAgaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0sIGkgKSB7XG4gICAgaXRlbS5zdGFnZ2VyKCBpICogc3RhZ2dlciApO1xuICAgIGl0ZW0uaGlkZSgpO1xuICB9KTtcbn07XG5cbi8qKlxuICogcmV2ZWFsIGl0ZW0gZWxlbWVudHNcbiAqIEBwYXJhbSB7QXJyYXl9LCB7RWxlbWVudH0sIHtOb2RlTGlzdH0gaXRlbXNcbiAqL1xucHJvdG8ucmV2ZWFsSXRlbUVsZW1lbnRzID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgaXRlbXMgPSB0aGlzLmdldEl0ZW1zKCBlbGVtcyApO1xuICB0aGlzLnJldmVhbCggaXRlbXMgKTtcbn07XG5cbi8qKlxuICogaGlkZSBpdGVtIGVsZW1lbnRzXG4gKiBAcGFyYW0ge0FycmF5fSwge0VsZW1lbnR9LCB7Tm9kZUxpc3R9IGl0ZW1zXG4gKi9cbnByb3RvLmhpZGVJdGVtRWxlbWVudHMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMuZ2V0SXRlbXMoIGVsZW1zICk7XG4gIHRoaXMuaGlkZSggaXRlbXMgKTtcbn07XG5cbi8qKlxuICogZ2V0IE91dGxheWVyLkl0ZW0sIGdpdmVuIGFuIEVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtPdXRsYXllci5JdGVtfSBpdGVtXG4gKi9cbnByb3RvLmdldEl0ZW0gPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgLy8gbG9vcCB0aHJvdWdoIGl0ZW1zIHRvIGdldCB0aGUgb25lIHRoYXQgbWF0Y2hlc1xuICBmb3IgKCB2YXIgaT0wOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNbaV07XG4gICAgaWYgKCBpdGVtLmVsZW1lbnQgPT0gZWxlbSApIHtcbiAgICAgIC8vIHJldHVybiBpdGVtXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogZ2V0IGNvbGxlY3Rpb24gb2YgT3V0bGF5ZXIuSXRlbXMsIGdpdmVuIEVsZW1lbnRzXG4gKiBAcGFyYW0ge0FycmF5fSBlbGVtc1xuICogQHJldHVybnMge0FycmF5fSBpdGVtcyAtIE91dGxheWVyLkl0ZW1zXG4gKi9cbnByb3RvLmdldEl0ZW1zID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICBlbGVtcyA9IHV0aWxzLm1ha2VBcnJheSggZWxlbXMgKTtcbiAgdmFyIGl0ZW1zID0gW107XG4gIGVsZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKCBlbGVtICk7XG4gICAgaWYgKCBpdGVtICkge1xuICAgICAgaXRlbXMucHVzaCggaXRlbSApO1xuICAgIH1cbiAgfSwgdGhpcyApO1xuXG4gIHJldHVybiBpdGVtcztcbn07XG5cbi8qKlxuICogcmVtb3ZlIGVsZW1lbnQocykgZnJvbSBpbnN0YW5jZSBhbmQgRE9NXG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEVsZW1lbnR9IGVsZW1zXG4gKi9cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgdmFyIHJlbW92ZUl0ZW1zID0gdGhpcy5nZXRJdGVtcyggZWxlbXMgKTtcblxuICB0aGlzLl9lbWl0Q29tcGxldGVPbkl0ZW1zKCAncmVtb3ZlJywgcmVtb3ZlSXRlbXMgKTtcblxuICAvLyBiYWlsIGlmIG5vIGl0ZW1zIHRvIHJlbW92ZVxuICBpZiAoICFyZW1vdmVJdGVtcyB8fCAhcmVtb3ZlSXRlbXMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlbW92ZUl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgLy8gcmVtb3ZlIGl0ZW0gZnJvbSBjb2xsZWN0aW9uXG4gICAgdXRpbHMucmVtb3ZlRnJvbSggdGhpcy5pdGVtcywgaXRlbSApO1xuICB9LCB0aGlzICk7XG59O1xuXG4vLyAtLS0tLSBkZXN0cm95IC0tLS0tIC8vXG5cbi8vIHJlbW92ZSBhbmQgZGlzYWJsZSBPdXRsYXllciBpbnN0YW5jZVxucHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAvLyBjbGVhbiB1cCBkeW5hbWljIHN0eWxlc1xuICB2YXIgc3R5bGUgPSB0aGlzLmVsZW1lbnQuc3R5bGU7XG4gIHN0eWxlLmhlaWdodCA9ICcnO1xuICBzdHlsZS5wb3NpdGlvbiA9ICcnO1xuICBzdHlsZS53aWR0aCA9ICcnO1xuICAvLyBkZXN0cm95IGl0ZW1zXG4gIHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgaXRlbS5kZXN0cm95KCk7XG4gIH0pO1xuXG4gIHRoaXMudW5iaW5kUmVzaXplKCk7XG5cbiAgdmFyIGlkID0gdGhpcy5lbGVtZW50Lm91dGxheWVyR1VJRDtcbiAgZGVsZXRlIGluc3RhbmNlc1sgaWQgXTsgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBpbnN0YW5jZSBieSBpZFxuICBkZWxldGUgdGhpcy5lbGVtZW50Lm91dGxheWVyR1VJRDtcbiAgLy8gcmVtb3ZlIGRhdGEgZm9yIGpRdWVyeVxuICBpZiAoIGpRdWVyeSApIHtcbiAgICBqUXVlcnkucmVtb3ZlRGF0YSggdGhpcy5lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLm5hbWVzcGFjZSApO1xuICB9XG5cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGRhdGEgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBnZXQgT3V0bGF5ZXIgaW5zdGFuY2UgZnJvbSBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqIEByZXR1cm5zIHtPdXRsYXllcn1cbiAqL1xuT3V0bGF5ZXIuZGF0YSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICBlbGVtID0gdXRpbHMuZ2V0UXVlcnlFbGVtZW50KCBlbGVtICk7XG4gIHZhciBpZCA9IGVsZW0gJiYgZWxlbS5vdXRsYXllckdVSUQ7XG4gIHJldHVybiBpZCAmJiBpbnN0YW5jZXNbIGlkIF07XG59O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGNyZWF0ZSBPdXRsYXllciBjbGFzcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIGNyZWF0ZSBhIGxheW91dCBjbGFzc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICovXG5PdXRsYXllci5jcmVhdGUgPSBmdW5jdGlvbiggbmFtZXNwYWNlLCBvcHRpb25zICkge1xuICAvLyBzdWItY2xhc3MgT3V0bGF5ZXJcbiAgdmFyIExheW91dCA9IHN1YmNsYXNzKCBPdXRsYXllciApO1xuICAvLyBhcHBseSBuZXcgb3B0aW9ucyBhbmQgY29tcGF0T3B0aW9uc1xuICBMYXlvdXQuZGVmYXVsdHMgPSB1dGlscy5leHRlbmQoIHt9LCBPdXRsYXllci5kZWZhdWx0cyApO1xuICB1dGlscy5leHRlbmQoIExheW91dC5kZWZhdWx0cywgb3B0aW9ucyApO1xuICBMYXlvdXQuY29tcGF0T3B0aW9ucyA9IHV0aWxzLmV4dGVuZCgge30sIE91dGxheWVyLmNvbXBhdE9wdGlvbnMgICk7XG5cbiAgTGF5b3V0Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICBMYXlvdXQuZGF0YSA9IE91dGxheWVyLmRhdGE7XG5cbiAgLy8gc3ViLWNsYXNzIEl0ZW1cbiAgTGF5b3V0Lkl0ZW0gPSBzdWJjbGFzcyggSXRlbSApO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGRlY2xhcmF0aXZlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgdXRpbHMuaHRtbEluaXQoIExheW91dCwgbmFtZXNwYWNlICk7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0galF1ZXJ5IGJyaWRnZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gIC8vIG1ha2UgaW50byBqUXVlcnkgcGx1Z2luXG4gIGlmICggalF1ZXJ5ICYmIGpRdWVyeS5icmlkZ2V0ICkge1xuICAgIGpRdWVyeS5icmlkZ2V0KCBuYW1lc3BhY2UsIExheW91dCApO1xuICB9XG5cbiAgcmV0dXJuIExheW91dDtcbn07XG5cbmZ1bmN0aW9uIHN1YmNsYXNzKCBQYXJlbnQgKSB7XG4gIGZ1bmN0aW9uIFN1YkNsYXNzKCkge1xuICAgIFBhcmVudC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gIH1cblxuICBTdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG4gIFN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YkNsYXNzO1xuXG4gIHJldHVybiBTdWJDbGFzcztcbn1cblxuLy8gLS0tLS0gaGVscGVycyAtLS0tLSAvL1xuXG4vLyBob3cgbWFueSBtaWxsaXNlY29uZHMgYXJlIGluIGVhY2ggdW5pdFxudmFyIG1zVW5pdHMgPSB7XG4gIG1zOiAxLFxuICBzOiAxMDAwXG59O1xuXG4vLyBtdW5nZSB0aW1lLWxpa2UgcGFyYW1ldGVyIGludG8gbWlsbGlzZWNvbmQgbnVtYmVyXG4vLyAnMC40cycgLT4gNDBcbmZ1bmN0aW9uIGdldE1pbGxpc2Vjb25kcyggdGltZSApIHtcbiAgaWYgKCB0eXBlb2YgdGltZSA9PSAnbnVtYmVyJyApIHtcbiAgICByZXR1cm4gdGltZTtcbiAgfVxuICB2YXIgbWF0Y2hlcyA9IHRpbWUubWF0Y2goIC8oXlxcZCpcXC4/XFxkKikoXFx3KikvICk7XG4gIHZhciBudW0gPSBtYXRjaGVzICYmIG1hdGNoZXNbMV07XG4gIHZhciB1bml0ID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzJdO1xuICBpZiAoICFudW0ubGVuZ3RoICkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIG51bSA9IHBhcnNlRmxvYXQoIG51bSApO1xuICB2YXIgbXVsdCA9IG1zVW5pdHNbIHVuaXQgXSB8fCAxO1xuICByZXR1cm4gbnVtICogbXVsdDtcbn1cblxuLy8gLS0tLS0gZmluIC0tLS0tIC8vXG5cbi8vIGJhY2sgaW4gZ2xvYmFsXG5PdXRsYXllci5JdGVtID0gSXRlbTtcblxucmV0dXJuIE91dGxheWVyO1xuXG59KSk7XG4iXSwibmFtZXMiOlsid2luZG93IiwiZmFjdG9yeSIsImRlZmluZSIsImFtZCIsIkV2RW1pdHRlciIsImdldFNpemUiLCJ1dGlscyIsIkl0ZW0iLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIk91dGxheWVyIiwiZml6enlVSVV0aWxzIiwiY29uc29sZSIsImpRdWVyeSIsIm5vb3AiLCJHVUlEIiwiaW5zdGFuY2VzIiwiZWxlbWVudCIsIm9wdGlvbnMiLCJxdWVyeUVsZW1lbnQiLCJnZXRRdWVyeUVsZW1lbnQiLCJlcnJvciIsImNvbnN0cnVjdG9yIiwibmFtZXNwYWNlIiwiJGVsZW1lbnQiLCJleHRlbmQiLCJkZWZhdWx0cyIsIm9wdGlvbiIsImlkIiwib3V0bGF5ZXJHVUlEIiwiX2NyZWF0ZSIsImlzSW5pdExheW91dCIsIl9nZXRPcHRpb24iLCJsYXlvdXQiLCJjb250YWluZXJTdHlsZSIsInBvc2l0aW9uIiwiaW5pdExheW91dCIsIm9yaWdpbkxlZnQiLCJvcmlnaW5Ub3AiLCJyZXNpemUiLCJyZXNpemVDb250YWluZXIiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJoaWRkZW5TdHlsZSIsIm9wYWNpdHkiLCJ0cmFuc2Zvcm0iLCJ2aXNpYmxlU3R5bGUiLCJwcm90byIsInByb3RvdHlwZSIsIm9wdHMiLCJvbGRPcHRpb24iLCJjb21wYXRPcHRpb25zIiwidW5kZWZpbmVkIiwiaG9yaXpvbnRhbCIsImxheW91dEluc3RhbnQiLCJyZWxvYWRJdGVtcyIsInN0YW1wcyIsInN0YW1wIiwic3R5bGUiLCJjYW5CaW5kUmVzaXplIiwiYmluZFJlc2l6ZSIsIml0ZW1zIiwiX2l0ZW1pemUiLCJjaGlsZHJlbiIsImVsZW1zIiwiaXRlbUVsZW1zIiwiX2ZpbHRlckZpbmRJdGVtRWxlbWVudHMiLCJpIiwibGVuZ3RoIiwiZWxlbSIsIml0ZW0iLCJwdXNoIiwiZmlsdGVyRmluZEVsZW1lbnRzIiwiaXRlbVNlbGVjdG9yIiwiZ2V0SXRlbUVsZW1lbnRzIiwibWFwIiwiX3Jlc2V0TGF5b3V0IiwiX21hbmFnZVN0YW1wcyIsImlzSW5zdGFudCIsIl9pc0xheW91dEluaXRlZCIsImxheW91dEl0ZW1zIiwiX2luaXQiLCJzaXplIiwiX2dldE1lYXN1cmVtZW50IiwibWVhc3VyZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiSFRNTEVsZW1lbnQiLCJfZ2V0SXRlbXNGb3JMYXlvdXQiLCJfbGF5b3V0SXRlbXMiLCJfcG9zdExheW91dCIsImZpbHRlciIsImlzSWdub3JlZCIsIl9lbWl0Q29tcGxldGVPbkl0ZW1zIiwicXVldWUiLCJmb3JFYWNoIiwiX2dldEl0ZW1MYXlvdXRQb3NpdGlvbiIsImlzTGF5b3V0SW5zdGFudCIsIl9wcm9jZXNzTGF5b3V0UXVldWUiLCJ4IiwieSIsInVwZGF0ZVN0YWdnZXIiLCJvYmoiLCJfcG9zaXRpb25JdGVtIiwic3RhZ2dlciIsImdldE1pbGxpc2Vjb25kcyIsImdvVG8iLCJtb3ZlVG8iLCJpc1Jlc2l6aW5nQ29udGFpbmVyIiwiX2dldENvbnRhaW5lclNpemUiLCJfc2V0Q29udGFpbmVyTWVhc3VyZSIsIndpZHRoIiwiaGVpZ2h0IiwibWVhc3VyZSIsImlzV2lkdGgiLCJlbGVtU2l6ZSIsImlzQm9yZGVyQm94IiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJSaWdodFdpZHRoIiwicGFkZGluZ0JvdHRvbSIsInBhZGRpbmdUb3AiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwiTWF0aCIsIm1heCIsImV2ZW50TmFtZSIsIl90aGlzIiwib25Db21wbGV0ZSIsImRpc3BhdGNoRXZlbnQiLCJjb3VudCIsImRvbmVDb3VudCIsInRpY2siLCJvbmNlIiwidHlwZSIsImV2ZW50IiwiYXJncyIsImVtaXRBcmdzIiwiY29uY2F0IiwiZW1pdEV2ZW50IiwiJGV2ZW50IiwiRXZlbnQiLCJ0cmlnZ2VyIiwiaWdub3JlIiwiZ2V0SXRlbSIsInVuaWdub3JlIiwiX2ZpbmQiLCJ1bnN0YW1wIiwicmVtb3ZlRnJvbSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJtYWtlQXJyYXkiLCJfZ2V0Qm91bmRpbmdSZWN0IiwiX21hbmFnZVN0YW1wIiwiYm91bmRpbmdSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiX2JvdW5kaW5nUmVjdCIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsIl9nZXRFbGVtZW50T2Zmc2V0IiwidGhpc1JlY3QiLCJvZmZzZXQiLCJtYXJnaW5MZWZ0IiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJoYW5kbGVFdmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJpc1Jlc2l6ZUJvdW5kIiwidW5iaW5kUmVzaXplIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9ucmVzaXplIiwiZGVib3VuY2VNZXRob2QiLCJuZWVkc1Jlc2l6ZUxheW91dCIsImhhc1NpemVzIiwiaW5uZXJXaWR0aCIsImFkZEl0ZW1zIiwiYXBwZW5kZWQiLCJyZXZlYWwiLCJwcmVwZW5kZWQiLCJwcmV2aW91c0l0ZW1zIiwic2xpY2UiLCJoaWRlIiwicmV2ZWFsSXRlbUVsZW1lbnRzIiwiZ2V0SXRlbXMiLCJoaWRlSXRlbUVsZW1lbnRzIiwicmVtb3ZlIiwicmVtb3ZlSXRlbXMiLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsImRhdGEiLCJjcmVhdGUiLCJMYXlvdXQiLCJzdWJjbGFzcyIsImh0bWxJbml0IiwiYnJpZGdldCIsIlBhcmVudCIsIlN1YkNsYXNzIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJPYmplY3QiLCJtc1VuaXRzIiwibXMiLCJzIiwidGltZSIsIm1hdGNoZXMiLCJtYXRjaCIsIm51bSIsInVuaXQiLCJwYXJzZUZsb2F0IiwibXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/outlayer/outlayer.js\n");

/***/ })

};
;